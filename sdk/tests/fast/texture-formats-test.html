<!--
Copyright (c) 2009 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>WebGL Texture Format Conformance Tests</title>
<link rel="stylesheet" href="../resources/js-test-style.css"/>
<script src="../resources/desktop-gl-constants.js" type="text/javascript"></script>
<script src="../resources/js-test-pre.js"></script>
<script src="resources/webgl-test.js"></script>
</head>
<body>
<div id="description"></div>
<div id="console"></div>
<canvas id="canvas" width="2" height="2"> </canvas>
<script>
description("This test ensures WebGL implementations allow the OpenGL ES 2.0 texture formats and do not allow DesktopGL texture formats.");

debug("");
debug("Canvas.getContext");

var gl = create3DContext(document.getElementById("canvas"));
if (!gl) {
  testFailed("context does not exist");
} else {
  testPassed("context exists");

  debug("");
  debug("Checking texture formats.");

  function createTexture(internalFormat, format, opt_border) {
      var border = (opt_border === undefined) ? 0 : opt_border;
      var tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D,
                    0,                 // level
                    internalFormat,    // internalFormat
                    16,                // width
                    16,                // height
                    border,            // border
                    format,            // format
                    gl.UNSIGNED_BYTE,  // type
                    null);             // data
  }

  function testValidFormat(internalFormat, formatName) {
      createTexture(internalFormat, internalFormat);
      assertMsg(gl.getError() == gl.NO_ERROR,
                "was able to create texture of " + formatName);
  }

  function testInvalidFormat(internalFormat, formatName) {
      createTexture(internalFormat, gl.RGBA);
      var err = gl.getError();
      if (err == gl.NO_ERROR) {
          testFailed("should NOT be able to create texture of type " + formatName);
      } else if (err == gl.INVALID_ENUM) {
          testFailed("should return gl.INVALID_OPERATION for type " + formatName);
      } else if (err == gl.INVALID_OPERATION) {
          testPassed("not able to create invalid format: " + formatName);
      }
  }

  var invalidEnums = [
    '1',
    '2',
    '3',
    '4',
    'RGB4',
    'RGB5',
    'RGB8',
    'RGB10',
    'RGB12',
    'RGB16',
    'RGBA2',
    'RGBA4',
    'RGB5_A1',
    'RGBA8',
    'RGB10_A2',
    'RGBA12',
    'RGBA16',
    'BGR',
    'BGRA',
    'ALPHA4_EXT',
    'ALPHA8_EXT',
    'ALPHA12_EXT',
    'ALPHA16_EXT',
    'COMPRESSED_ALPHA',
    'COMPRESSED_LUMINANCE',
    'COMPRESSED_LUMINANCE_ALPHA',
    'COMPRESSED_INTENSITY',
    'COMPRESSED_RGB',
    'COMPRESSED_RGBA',
    'DEPTH_COMPONENT16',
    'DEPTH_COMPONENT24',
    'DEPTH_COMPONENT32',
    'LUMINANCE4_EXT',
    'LUMINANCE8_EXT',
    'LUMINANCE12_EXT',
    'LUMINANCE16_EXT',
    'LUMINANCE4_ALPHA4_EXT',
    'LUMINANCE6_ALPHA2_EXT',
    'LUMINANCE8_ALPHA8_EXT',
    'LUMINANCE12_ALPHA4_EXT',
    'LUMINANCE12_ALPHA12_EXT',
    'LUMINANCE16_ALPHA16_EXT',
    'INTENSITY_EXT',
    'INTENSITY4_EXT',
    'INTENSITY8_EXT',
    'INTENSITY12_EXT',
    'INTENSITY16_EXT',
    'RGB4_EXT',
    'RGB5_EXT',
    'RGB8_EXT',
    'RGB10_EXT',
    'RGB12_EXT',
    'RGB16_EXT',
    'RGBA2_EXT',
    'RGBA4_EXT',
    'RGB5_A1_EXT',
    'RGBA8_EXT',
    'RGB10_A2_EXT',
    'RGBA12_EXT',
    'RGBA16_EXT',
    'SLUMINANCE_EXT',
    'SLUMINANCE8_EXT',
    'SLUMINANCE_ALPHA_EXT',
    'SLUMINANCE8_ALPHA8_EXT',
    'SRGB_EXT',
    'SRGB8_EXT',
    'SRGB_ALPHA_EXT',
    'SRGB8_ALPHA8'
  ];

  for (var ii = 0; ii < invalidEnums.length; ++ii) {
    var formatName = invalidEnums[ii]
    if (desktopGL[formatName] === undefined) {
      debug("bad format" + formatName)
    } else {
      testInvalidFormat(desktopGL[formatName], "GL_" + formatName);
    }
  }

  var validEnums = [
    'ALPHA',
    'RGB',
    'RGBA',
    'LUMINANCE',
    'LUMINANCE_ALPHA'
  ];

  for (var ii = 0; ii < validEnums.length; ++ii) {
    var formatName = validEnums[ii]
    testValidFormat(gl[formatName], "gl." + formatName);
  }

  debug("");
  debug("checking non 0 border parameter to gl.TexImage2D");
  createTexture(gl['RGBA'], gl['RGBA'], 1);
  assertMsg(gl.getError() == gl.INVALID_VALUE,
            "non 0 border to gl.TexImage2D should return INVALID_VALUE");
}

debug("");
successfullyParsed = true;

</script>
<script src="../resources/js-test-post.js"></script>

<script>
</script>

</body>
</html>
