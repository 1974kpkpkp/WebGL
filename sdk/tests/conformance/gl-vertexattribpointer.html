<!--
Copyright (c) 2009 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>WebGL vertexAttribPointer Conformance Tests</title>
<link rel="stylesheet" href="../resources/js-test-style.css"/>
<script src="../resources/desktop-gl-constants.js" type="text/javascript"></script>
<script src="../resources/js-test-pre.js"></script>
<script src="resources/webgl-test.js"></script>
<script src="resources/webgl-test-utils.js"></script>
</head>
<body>
<div id="description"></div>
<div id="console"></div>
<canvas id="canvas" width="2" height="2"> </canvas>
<script>
description("This test checks vertexAttribPointer behaviors in WebGL.");

debug("");
debug("Canvas.getContext");

var wtu = WebGLTestUtils;
var gl = create3DContext(document.getElementById("canvas"));
if (!gl) {
  testFailed("context does not exist");
} else {
  testPassed("context exists");

  debug("");
  debug("Checking gl.vertexAttribPointer.");

  if (!gl.FIXED) {
    gl.FIXED = 0x140C;
  }

  gl.vertexAttribPointer(0, 3, gl.FLOAT, 0, 0, 12);
  glErrorShouldBe(gl, gl.INVALID_OPERATION,
      "vertexAttribPointer should fail if no buffer is bound");

  var vertexObject = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexObject);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(0), gl.STATIC_DRAW);

  gl.vertexAttribPointer(0, 1, gl.INT, 0, 0, 0);
  glErrorShouldBe(gl, gl.INVALID_ENUM,
      "vertexAttribPointer should not support INT");
  gl.vertexAttribPointer(0, 1, gl.UNSIGNED_INT, 0, 0, 0);
  glErrorShouldBe(gl, gl.INVALID_ENUM,
      "vertexAttribPointer should not support UNSIGNED_INT");
  gl.vertexAttribPointer(0, 1, gl.FIXED, 0, 0, 0);
  glErrorShouldBe(gl, gl.INVALID_ENUM,
      "vertexAttribPointer should not support FIXED");

  var count = 0;
  function checkVertexAttribPointer(
      gl, err, reason, size, type, normalize, stride, offset) {
    gl.vertexAttribPointer(0, size, type, normalize, stride, offset);
    glErrorShouldBe(gl, err,
        "(" + count + ") " +
        "gl.vertexAttribPointer(0, " + size +
        ", gl." + wtu.glEnumToString(gl, type) +
        ", " + normalize +
        ", " + stride +
        ", " + offset +
        ") should " + (err == gl.NO_ERROR ? "succeed " : "fail ") + reason);
    ++count;
  }

  var types = [
    { type:gl.BYTE,           bytesPerComponent: 1 },
    { type:gl.UNSIGNED_BYTE,  bytesPerComponent: 1 },
    { type:gl.SHORT,          bytesPerComponent: 2 },
    { type:gl.UNSIGNED_SHORT, bytesPerComponent: 2 },
    { type:gl.FLOAT,          bytesPerComponent: 4 },
  ];

  for (var ii = 0; ii < types.length; ++ii) {
    var info = types[ii];
    debug("");
    for (var size = 1; size <= 4; ++size) {
      debug("");
      debug("checking: " + wtu.glEnumToString(gl, info.type) + " with size " +
            size);
      var bytesPerElement = size * info.bytesPerComponent;
      for (var off = 0; off < 4; ++off) {
        for (var ss = 0; ss < info.bytesPerComponent; ++ss) {
          var offset = bytesPerElement * off + ss;
          for (var n = 0; n < 2; ++n) {
            for (var st = 0; st < bytesPerElement * 2; ++st) {
              var stride = st;
              var err = gl.NO_ERROR;
              var reason = ""
              if (ss != 0) {
                reason = "because offset is bad";
                err = gl.INVALID_OPERATION;
              }
              if (st % info.bytesPerComponent != 0) {
                reason = "because stride is bad";
                err = gl.INVALID_OPERATION;
              }
              checkVertexAttribPointer(
                  gl, err, reason, size, info.type, (n != 0), stride, offset);
            }
            var stride = Math.floor(255 / info.bytesPerComponent) *
                info.bytesPerComponent;

            if (ss == 0) {
              checkVertexAttribPointer(
                  gl, gl.NO_ERROR, "at stide limit",
                  size, info.type, (n != 0), stride, offset);
              checkVertexAttribPointer(
                  gl, gl.INVALID_VALUE, "over stride limit",
                  size, info.type, (n != 0),
                  stride + info.bytesPerComponent, offset);
            }
          }
        }
      }
    }
  }
}

debug("");
successfullyParsed = true;

</script>
<script src="../resources/js-test-post.js"></script>

<script>
</script>

</body>
</html>
