/*
 * typedarrays.idl
 *
 * TypedArray IDL definitions scraped from the Khronos specification, revised for esidl.
 *
 * Original Khronos Working Draft:
 *
 *   https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html
 */

module typedarrays {

[ Constructor(unsigned long length) ]
interface ArrayBuffer {
    readonly attribute unsigned long byteLength;
};


interface ArrayBufferView {
    readonly attribute ArrayBuffer buffer;
    readonly attribute unsigned long byteOffset;
    readonly attribute unsigned long byteLength;

};

// The 'byte' type does not currently exist in Web IDL.
// In this IDL, it should be a signed 8 bit type.
[
    Constructor(unsigned long length),
    Constructor(Int8Array array),
    Constructor(sequence<byte> array),
    Constructor(ArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface Int8Array : ArrayBufferView {
    const long BYTES_PER_ELEMENT = 1;

    readonly attribute unsigned long length;
    
    getter byte (unsigned long index);
    setter void (unsigned long index, byte value);
    void set(Int8Array array, optional unsigned long offset);
    void set(sequence<byte> array, optional unsigned long offset);
    Int8Array slice(long start, long end);
};

// The 'unsigned byte' type does not currently exist in Web IDL, though
// 'octet' is equivalent.
[
    Constructor(unsigned long length),
    Constructor(Uint8Array array),
    Constructor(sequence<unsigned byte> array),
    Constructor(ArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface Uint8Array : ArrayBufferView {
    const long BYTES_PER_ELEMENT = 1;
    
    readonly attribute unsigned long length;
    
    getter unsigned byte (unsigned long index);
    setter void (unsigned long index, unsigned byte value);
    void set(Uint8Array array, optional unsigned long offset);
    void set(sequence<unsigned byte> array, optional unsigned long offset);
    Uint8Array slice(long start, long end);
};


[
    Constructor(unsigned long length),
    Constructor(Int16Array array),
    Constructor(sequence<short> array),
    Constructor(ArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface Int16Array : ArrayBufferView {
    const long BYTES_PER_ELEMENT = 2;
    
    readonly attribute unsigned long length;
    
    getter short (unsigned long index);
    setter void (unsigned long index, short value);
    void set(Int16Array array, optional unsigned long offset);
    void set(sequence<short> array, optional unsigned long offset);
    Int16Array slice(long start, long end);
};


[
    Constructor(unsigned long length),
    Constructor(Uint16Array array),
    Constructor(sequence<unsigned short> array),
    Constructor(ArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface Uint16Array : ArrayBufferView {
    const long BYTES_PER_ELEMENT = 2;
    
    readonly attribute unsigned long length;
    
    getter unsigned short (unsigned long index);
    setter void (unsigned long index, unsigned short value);
    void set(Uint16Array array, optional unsigned long offset);
    void set(sequence<unsigned short> array, optional unsigned long offset);
    Uint16Array slice(long start, long end);
};


[
    Constructor(unsigned long length),
    Constructor(Int32Array array),
    Constructor(sequence<long> array),
    Constructor(ArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface Int32Array : ArrayBufferView {
    const long BYTES_PER_ELEMENT = 4;
    
    readonly attribute unsigned long length;
    
    getter long (unsigned long index);
    setter void (unsigned long index, long value);
    void set(Int32Array array, optional unsigned long offset);
    void set(sequence<long> array, optional unsigned long offset);
    Int32Array slice(long start, long end);
};


[
    Constructor(unsigned long length),
    Constructor(Uint32Array array),
    Constructor(sequence<unsigned long> array),
    Constructor(ArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface Uint32Array : ArrayBufferView {
    const long BYTES_PER_ELEMENT = 4;
    
    readonly attribute unsigned long length;
    
    getter unsigned long (unsigned long index);
    setter void (unsigned long index, unsigned long value);
    void set(Uint32Array array, optional unsigned long offset);
    void set(sequence<unsigned long> array, optional unsigned long offset);
    Uint32Array slice(long start, long end);
};


[
    Constructor(unsigned long length),
    Constructor(FloatArray array),
    Constructor(sequence<float> array),
    Constructor(ArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface FloatArray : ArrayBufferView {
    const long BYTES_PER_ELEMENT = 4;
    
    readonly attribute unsigned long length;
    
    getter float (unsigned long index);
    setter void (unsigned long index, float value);
    void set(FloatArray array, optional unsigned long offset);
    void set(sequence<float> array, optional unsigned long offset);
    FloatArray slice(long start, long end);
};

[
  Constructor(ArrayBuffer buffer,
              optional unsigned long byteOffset,
              optional unsigned long byteLength)
]
interface DataArray : ArrayBufferView {
    // Gets the value of the given type at the specified byte offset
    // from the start of the view. There is no alignment constraint;
    // multi-byte values may be fetched from any offset.
    //
    // For multi-byte values, the optional littleEndian argument
    // indicates whether a big-endian or little-endian value should be
    // read. If false or undefined, a big-endian value is read.
    //
    // These methods raise an INDEX_SIZE_ERR exception if they would read
    // beyond the end of the view.
    byte getInt8(unsigned long byteOffset);
    unsigned byte getUInt8(unsigned long byteOffset);
    short getInt16(unsigned long byteOffset,
                   optional boolean littleEndian);
    unsigned short getUInt16(unsigned long byteOffset,
                             optional boolean littleEndian);
    long getInt32(unsigned long byteOffset,
                  optional boolean littleEndian);
    unsigned long getUInt32(unsigned long byteOffset,
                            optional boolean littleEndian);
    long long getInt64(unsigned long byteOffset,
                       optional boolean littleEndian);
    unsigned long long getUInt64(unsigned long byteOffset,
                                 optional boolean littleEndian);
    float getFloat(unsigned long byteOffset,
                   optional boolean littleEndian);
    double getDouble(unsigned long byteOffset,
                     optional boolean littleEndian);

    // Stores a value of the given type at the specified byte offset
    // from the start of the view. There is no alignment constraint;
    // multi-byte values may be stored at any offset.
    //
    // For multi-byte values, the optional littleEndian argument
    // indicates whether the value should be stored in big-endian or
    // little-endian byte order. If false or undefined, the value is
    // stored in big-endian byte order.
    //
    // These methods throw exceptions if they would write beyond the end
    // of the view.
    void setInt8(unsigned long byteOffset,
                 byte value,
                 optional boolean littleEndian);
    void setUint8(unsigned long byteOffset,
                  unsigned byte value,
                  optional boolean littleEndian);
    void setInt16(unsigned long byteOffset,
                  short value,
                  optional boolean littleEndian);
    void setUint16(unsigned long byteOffset,
                   unsigned short value,
                   optional boolean littleEndian);
    void setInt32(unsigned long byteOffset,
                  long value,
                  optional boolean littleEndian);
    void setUint32(unsigned long byteOffset,
                   unsigned long value,
                   optional boolean littleEndian);
    void setInt64(unsigned long byteOffset,
                  long long value,
                  optional boolean littleEndian);
    void setUint64(unsigned long byteOffset,
                   unsigned long long value,
                   optional boolean littleEndian);
    void setFloat(unsigned long byteOffset,
                  float value,
                  optional boolean littleEndian);
    void setDouble(unsigned long byteOffset,
                   double value,
                   optional boolean littleEndian);
};

};
