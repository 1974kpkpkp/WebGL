<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Typed Array Specification</title>
  <link rel="stylesheet" type="text/css" href="Khronos-WD.css" />
  <link rel="stylesheet" type="text/css" href="default.css" />
  <script src="jquery-1.3.2.min.js" type="text/javascript"></script>
  <script src="generateTOC.js" type="text/javascript"></script>


    <style type="text/css">
.view-example-table * {
  text-align: center;
}
.view-example-table tr > td:first-child {
  font-family: fixed;
  text-align: right;
  border: none;
}
.view-example-table td {
  padding: 4px 8px 4px 8px;
}

.api tbody tr > td {
  vertical-align: baseline;
}
    </style>
</head>

<body onload="generateTOC(document.getElementById('toc'))">
  <h1>Typed Arrays</h1>
  <h2 class="no-toc">Working Draft 08 June 2010</h2>
  <dl>
    <dt>This version:
      <dd>
          <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html">
              https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html
          </a>
          <br>
          <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/typedarrays.idl">
              <b>Web IDL:</b> https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/typedarrays.idl
          </a>
      </dd>
    <dt>Latest version:
      <dd>
          <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html">
              https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html
          </a>
          <br>
          <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/typedarrays.idl">
              <b>Web IDL:</b> https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/typedarrays.idl
          </a>
      </dd>
    <dt>Previous version:
      <dd>
        none
      </dd>
    <dt>Editors:
      <dd>
        <a href="mailto:vladimir@mozilla.com">Vladimir Vukicevic</a>
        <a href="http://www.mozilla.com/">(Mozilla Corporation)</a>
      </dd>
      <dd>
        <a href="mailto:kbr@google.com">Kenneth Russell</a>
        <a href="http://www.google.com/intl/en/about.html">(Google, Inc.)</a>
      </dd>
  </dl>

  <hr />
    
    <h2 class="no-toc">Abstract</h2>
    <p>
      This specification provides an API for interoperability with
      native binary data.  It defines a generic fixed-length buffer
      type, as well as accessor types that allow access to the data
      stored within the buffer.
    </p>

    <p>
      The functionality described here originated in the WebGL
      specification <a href="#refsWEBGL">[WEBGL]</a>.
    </p>

    <h2 class="no-toc">Status of this document</h2>
    
    <!--begin-status-->
    <p>
        This is a working draft document and may be updated, replaced or obsoleted 
        by other documents at any time. Do not cite this document 
        as other than work in progress.  Public discussion of this draft specification 
        is welcome on the (<a href="https://www.khronos.org/webgl/public-mailing-list/archives">archived</a>) 
        WebGL mailing list <a href="mailto:"></a> (see
        <a href="https://www.khronos.org/webgl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->
    
    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>
    <p>
      <em>This section is not normative.</em>
    </p>

    <p>
      ECMAScript (REF) has traditionally been used in contexts where there
      is no access to binary data.  Where binary data has needed to be
      manipulated, it is often stored as a String and accessed using
      charCodeAt(), or stored as an Array with conversion to and from
      base64 for transmission.  Both of these methods are slow and
      error-prone.  For example, reading binary data as 32-bit
      integers requires manual conversion of 4 source bytes to and
      from the target type.  Reading floating-point data is even more
      expensive.
    </p>

    <p>
      As web applications gain access to new functionality, working
      with binary data has become a much-demanded feature.  Current
      specifications such as the File
      API <a href="#refsFILE">[FILEAPI]</a> and Web
      Sockets <a href="#refsWEBSOCKETS">[WEBSOCKETS]</a> would benefit
      from being able to read and write binary data directly in its
      native form.  Specifications such as
      WebGL <a href="#refsWEBGL">[WEBGL]</a> require this
      functionality to meet acceptable performance characteristics.
    </p>

    <p>
      This specification defines a minimal set of functionality for
      accessing binary data from ECMAScript.
    </p>

    <h2>Overview</h2>
    <p>
      <em>This section is not normative.</em>
    </p>

    <p>
      This specification defines an ArrayBuffer type, representing a generic fixed-length binary buffer.  It is not possible to manipulate the contents of an ArrayBuffer directly.  Instead, a group of types are used to create <i>views</i> of the ArrayBuffer.  For example, to access the buffer as an array of 32-bit signed integers, an Int32Array would be created that refers to the ArrayBuffer.
    </p>
    <p>
      Multiple typed array views can refer to the same ArrayBuffer, of different types, lengths, and offsets.  This allows for complex data structures to be built up in the ArrayBuffer.  As an example, given the following code:
    </p>
    <pre>
      // create an 8-byte ArrayBuffer
      var b = new ArrayBuffer(8);

      // create a view v1 referring to b, of type Int32, starting at
      // the default byte index (0) and extending until the end of the buffer
      var v1 = new Int32Array(b);

      // create a view v2 referring to b, of type Uint8, starting at
      // byte index 2 and extending until the end of the buffer
      var v2 = new Uint8Array(b, 2);

      // create a view v3 referring to b, of type Int16, starting at
      // byte index 2 and having a length of 2
      var v3 = new Int16Array(b, 2, 2);
    </pre>

    <p>
      The following buffer and view layout is created:
    </p>

    <center>
    <table class="view-example-table">
      <thead>
	<tr>
	  <th><i>var</i></th><th colspan="8"><i>index</i></th>
	</tr>
      </thead>
      <tbody>
	<tr style="font-size: small;">
	  <td></td><td colspan="8"><i>bytes (not indexable)</i></td>
	</tr>
	<tr>
	  <td>b = </td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
	</tr>
	<tr style="font-size: small;">
	  <td></td><td colspan="8"><i>indices</i></td>
	</tr>
	<tr>
	  <td>v1 = </td><td colspan="4">0</td><td colspan="4">1</td>
	</tr>
	<tr>
	  <td>v2 = </td><td colspan="2" style="background: #aaa"></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
	</tr>
	<tr>
	  <td>v3 = </td><td colspan="2" style="background: #aaa"></td><td colspan="2">0</td><td colspan="2">1</td><td colspan="2" style="background: #aaa"></td>
	</tr>
      </tbody>
    </table>
    </center>

    <p>
      This defines an 8-byte buffer <tt>b</tt>, and three views of
      that buffer, <tt>v1</tt>, <tt>v2</tt>, and <tt>v3</tt>.  Each of
      the views refers to the same buffer -- so <tt>v1[0]</tt> refers
      to bytes 0..3 as a signed 32-bit integer, <tt>v2[0]</tt> refers
      to byte 2 as a unsigned 8-bit integer, and <tt>v3[0]</tt> refers
      to bytes 2..3 as a signed 16-bit integer.  Any modification to
      one view is immediately visible in the other: for example,
      after <tt>v2[0] = 0xff; v2[1] = 0xff;</tt> then <tt>v3[0] ==
      -1</tt> (where -1 is represented as <tt>0xffff</tt>).
    </p>

    <h2>The <tt><a name="ARRAYBUFFER">ArrayBuffer</a></tt> Type</h2>

    <p>The <tt>ArrayBuffer</tt> type describes a buffer used to store
    data for the TypedArray interface and its subclasses.  An ArrayBuffer has the following methods and properties:</p>

    <pre class="idl">
[ Constructor(unsigned long length) ]
interface <dfn id="ArrayBuffer">ArrayBuffer</dfn> {
    readonly attribute unsigned long byteLength;
};</pre>

    <table class="api">
      <tbody>
	<tr><th colspan="2">Constructors</th></tr>
	<tr>
	  <td><i>ArrayBuffer</i>(unsigned long length)</td>
	  <td>
	    <p>Creates a new ArrayBuffer of the given length in bytes. The contents of the
	    ArrayBuffer are initialized to 0.</p>
	  </td>
	</tr>
	<tr></tr>
	<tr><th colspan="2">Properties</th></tr>
	<tr>
	  <td>unsigned long byteLength</td>
	  <td>
	    <p>Read-only property.</p>
	    <p>The length of the ArrayBuffer in bytes, as fixed at construction time.</p>
	  </td>
	</tr>
	<tr></tr>
	<tr><th colspan="2">Methods</th></tr>
	<tr><td colspan="2"><i>None</i></td></tr>
      </tbody>
    </table>

    <h2>The <tt><a name="ARRAYBUFFERVIEW">ArrayBufferView</a></tt> Type</h2>

    <p>The <tt>ArrayBufferView</tt> type holds information shared among all of the types of views of ArrayBuffers. An <tt>ArrayBufferView</tt> has the following properties:

    <pre class="idl">
interface <dfn id="ArrayBufferView">ArrayBufferView</dfn> {
    readonly attribute ArrayBuffer buffer;
    readonly attribute unsigned long byteOffset;
    readonly attribute unsigned long byteLength;
};</pre>

    <table class="api">
      <tbody>
	<tr><th colspan="2">Constructors</th></tr>
	<tr><td colspan="2"><i>None</i></td></tr>
	<tr></tr>
	<tr><th colspan="2">Properties</th></tr>
	<tr>
	  <td>ArrayBuffer buffer</td>
	  <td>
	    <p>Read-only property.</p>
	    <p>The <tt>ArrayBuffer</tt> that this <tt>ArrayBufferView</tt> references.</p>
	  </td>
	</tr>
	<tr>
	  <td>unsigned long byteOffset</td>
	  <td>
	    <p>Read-only property.</p>
	    <p>The offset of this <tt>ArrayBufferView</tt> from the start of its <tt>ArrayBuffer</tt>, in bytes, as fixed at construction time.</p>
	  </td>
	</tr>
	<tr>
	  <td>unsigned long byteLength</td>
	  <td>
	    <p>Read-only property.</p>
	    <p>The length of the <tt>ArrayBufferView</tt> in bytes, as fixed at construction time.</p>
	  </td>
	</tr>
	<tr></tr>
	<tr><th colspan="2">Methods</th></tr>
	<tr><td colspan="2"><i>None</i></td></tr>
      </tbody>
    </table>

    <h2><a name="TYPEDARRAYS">The Typed Array View Types</a></h2>

    <p>The typed array view types represent a view of
    an <tt>ArrayBuffer</tt> that allows for indexing and manipulation.
    The length of each of these is fixed.  Each of the typed array
    view types follows the same template.</p>

    <p>The following typed arrays are defined by this specification.  The size below is given in bytes, and corresponds to the <tt>BYTES_PER_ELEMENT</tt> constant for the given type.</p>

    <center><table>
      <thead>
	<tr><th>Type</th><th>Size</th><th>Description</th><th>Equivalent C Type</th></tr>
      </thead>
      <tbody>
	<tr><td><tt>Int8Array</tt></td><td>1</td><td>8-bit 2's complement signed integer</td><td><code>signed char</code></td></tr>
	<tr><td><tt>Uint8Array</tt></td><td>1</td><td>8-bit unsigned integer</td><td><code>unsigned char</code></td></tr>
	<tr><td><tt>Int16Array</tt></td><td>2</td><td>16-bit 2's complement signed integer</td><td><code>short</code></td></tr>
	<tr><td><tt>Uint16Array</tt></td><td>2</td><td>16-bit unsigned integer</td><td><code>unsigned short</code></td></tr>
	<tr><td><tt>Int32Array</tt></td><td>4</td><td>32-bit 2's complement signed integer</td><td><code>int</code></td></tr>
	<tr><td><tt>Uint32Array</tt></td><td>4</td><td>32-bit unsigned integer</td><td><code>unsigned int</code></td></tr>
	<tr><td><tt>Float32Array</tt></td><td>4</td><td>32-bit IEEE floating point</td><td><code>float</code></td></tr>
	<tr><td><tt>Float64Array</tt></td><td>8</td><td>64-bit IEEE floating point</td><td><code>double</code></td></tr>
      </tbody>
    </table></center>

    <p>Each of the typed array types has the following constructors,
    properties, constants and methods.  In the descriptions below, the
    generic term <i>TypedArray</i> is used to indicate that any valid
    typed array view type is allowed.</p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(<i>TypedArray</i> array),
    Constructor(sequence&lt;<i>type</i>&gt; array),
    Constructor(ArrayBuffer buffer,
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="TypedArray"><i>TypedArray</i></dfn> : ArrayBufferView {
    const unsigned long BYTES_PER_ELEMENT = <i>element size in bytes</i>;

    readonly attribute unsigned long length;

    omittable getter <i>type</i> get(unsigned long index);
    omittable setter void set(unsigned long index, <i>type</i> value);
    void set(<i>TypedArray</i> array, optional unsigned long offset);
    void set(sequence&lt;<i>type</i>&gt; array, optional unsigned long offset);
    <i>TypedArray</i> slice(long begin, optional long end);
};</pre>

    <table class="api">
      <tbody>
	<tr><th colspan="2">Constructors</th></tr>
	<tr>
	  <td><i>TypedArray</i>(unsigned long length)</td>
	  <td>
	    <p>Create a new ArrayBuffer with enough bytes to
	      hold <tt>length</tt> elements of this typed array, then
	      creates a typed array view referring to the full buffer.
	    </p>
	  </td>
	</tr>
	<tr>
	  <td><i>TypedArray</i>(<i>TypeArray</i> array)<br>
              <i>TypedArray</i>(sequence&lt;<i>type</i>&gt; array)</td>
	  <td>
	    <p>Create a new ArrayBuffer with enough bytes to
	      hold <tt>array.length</tt> elements of this typed array,
	      then creates a typed array view referring to the full
	      buffer.  The contents of the new view are initialized to
	      the contents of the given typed array or sequence, with
	      each element converted to the appropriate typed array
	      type.</p>
	  </td>
	</tr>
	<tr>
	  <td><i>TypedArray</i>(ArrayBuffer buffer,
              optional unsigned long byteOffset, optional unsigned long length)</td>
	  <td>
	    <p>Create a new <i>TypedArray</i> object using the passed
            ArrayBuffer for its storage. Optional byteOffset and
            length can be used to limit the section of the buffer
            referenced. The byteOffset indicates the offset in bytes
            from the start of the ArrayBuffer, and the length is the
            count of elements from the offset that
            this <i>TypedArray</i> will reference.  If both byteOffset
            and length are omitted, the <i>TypedArray</i> spans the
            entire ArrayBuffer range.  If the length is omitted, the
            <i>TypedArray</i> extends from the given byteOffset until
            the end of the ArrayBuffer.</p>
	      
	    <p>The given byteOffset must be a multiple of the element size
	    of the specific type, otherwise an exception is raised.</p>

	    <p>If a given byteOffset and length references an area beyond
	    the end of the ArrayBuffer an exception is raised.</p>

	    <p>If length is not explicitly specified, the length of the
	    ArrayBuffer minus the byteOffset must be a multiple of the
	    element size of the specific type, or an exception is raised.</p>
	  </td>
	</tr>
	<tr></tr>
	<tr><th colspan="2">Constants</th></tr>
	<tr>
	  <td>unsigned long BYTES_PER_ELEMENT</td>
	  <td>The size in bytes of each element in the array.</td>
	</tr>
	<tr><th colspan="2">Properties</th></tr>
	<tr>
	  <td>unsigned long length</td>
	  <td>
	    <p>Read-only property.</p>
	    <p>The length of the <tt>TypedArray</tt> in elements, as fixed at construction time.</p>
	  </td>
	</tr>
	<tr></tr>
	<tr><th colspan="2">Methods</th></tr>
	<tr>
	  <td>
	    <code>omittable getter</code> <i>type</i> get(unsigned long index)
	  </td>
	  <td>
	    <p>This is an index getter.</p>
	    <p>Returns the element at the given numeric index.</p>
	  </td>
	</tr>
	<tr>
	  <td>
	    <code>omittable setter</code> void set(unsigned long index, <i>type</i> value)
	  </td>
	  <td>
	    <p>This is an index setter.</p>
	    <p>Sets the element at the given numeric index to the given value.</p>
            <p>Conversions of values to <i>type</i> are defined in
            the <a href="http://dev.w3.org/2006/webapi/WebIDL/">Web
            IDL</a>
            specification <a href="#refsWEBIDL">[WEBIDL]</a>. See in
            particular
            the <a href="http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping">ECMAScript
            type mapping</a>.
	  </td>
	</tr>
	<tr>
	  <td>
	    void <i>set</i>(<i>TypedArray</i> array, optional unsigned long offset)<br>
	    void <i>set</i>(sequence&lt;<i>type</i>&gt; array, optional unsigned long offset)
	  </td>
	  <td>
            <p>
              Set multiple values, reading input values from the array.
              The optional offset value indicates the index in the current
              array where values are written.  If omitted, it is assumed to
              be 0.
            </p>
            <p>
              If the input array is a <i>TypedArray</i>, the two arrays may
              use the same underlying <code>ArrayBuffer</code>. In this
              situation, setting the values takes place as if all the data
              is first copied into a temporary buffer that does not overlap
              either of the arrays, and then the data from the temporary
              buffer is copied into the current array.
            </p>
            <p>
              If the offset plus the length of the given array is out of
              range for the current <i>TypedArray</i>, an exception is raised.
           </p>
	  </td>
	</tr>
	<tr>
	  <td>
	    <i>TypedArray</i> <i>slice</i>(long begin, optional long end)
	  </td>
	  <td>
	    <p>Returns a new <i>TypedArray</i> view of
             the <tt>ArrayBuffer</tt> store for this <i>TypedArray</i>,
             referencing the elements at <tt>begin</tt>, inclusive, up
             to <tt>end</tt>, exclusive.  If either <tt>begin</tt>
             or <tt>end</tt> is negative, it refers to an index from the
             end of the array, as opposed to from the beginning.
            </p>
            <p>
             If <tt>end</tt> is unspecified, the slice contains all
             elements from <tt>begin</tt> to the end of
             the <i>TypedArray</i>.
            </p>
            <p>
             The range specified by the <tt>begin</tt> and <tt>end</tt>
             values is clamped to the valid index range for the current
             array. If the computed length of the new <i>TypedArray</i>
             would be negative, it is clamped to zero.
            </p>
	    <p>The returned <i>TypedArray</i> will be of the same type
	    as the array on which this method is invoked.</p>
	  </td>
	</tr>
      </tbody>
    </table>

    <h2>The <tt>DataView</tt> View Type</h2>

    <p>An <tt>ArrayBuffer</tt> is a useful object for representing an arbitrary chunk of data.  In many cases, such data will be read from disk or from the network, and will not follow the alignment restrictions that are imposed on the typed array views described earlier.  In addition, the data will often be heterogeneous in nature and have a defined byte order.  The <tt>DataView</tt> view provides a low-level interface for reading such data from and writing it to an ArrayBuffer.</p>

    <pre class="idl">
[
  Constructor(ArrayBuffer buffer,
              optional unsigned long byteOffset,
              optional unsigned long byteLength)
]
interface <dfn id="DataView">DataView</dfn> : ArrayBufferView {
    // Gets the value of the given type at the specified byte offset
    // from the start of the view. There is no alignment constraint;
    // multi-byte values may be fetched from any offset.
    //
    // For multi-byte values, the optional littleEndian argument
    // indicates whether a big-endian or little-endian value should be
    // read. If false or undefined, a big-endian value is read.
    //
    // These methods raise an exception if they would read
    // beyond the end of the view.
    byte getInt8(unsigned long byteOffset);
    unsigned byte getUInt8(unsigned long byteOffset);
    short getInt16(unsigned long byteOffset,
                   optional boolean littleEndian);
    unsigned short getUInt16(unsigned long byteOffset,
                             optional boolean littleEndian);
    long getInt32(unsigned long byteOffset,
                  optional boolean littleEndian);
    unsigned long getUInt32(unsigned long byteOffset,
                            optional boolean littleEndian);
    float getFloat32(unsigned long byteOffset,
                     optional boolean littleEndian);
    double getFloat64(unsigned long byteOffset,
                      optional boolean littleEndian);

    // Stores a value of the given type at the specified byte offset
    // from the start of the view. There is no alignment constraint;
    // multi-byte values may be stored at any offset.
    //
    // For multi-byte values, the optional littleEndian argument
    // indicates whether the value should be stored in big-endian or
    // little-endian byte order. If false or undefined, the value is
    // stored in big-endian byte order.
    //
    // These methods raise an exception if they would write
    // beyond the end of the view.
    void setInt8(unsigned long byteOffset,
                 byte value,
                 optional boolean littleEndian);
    void setUint8(unsigned long byteOffset,
                  unsigned byte value,
                  optional boolean littleEndian);
    void setInt16(unsigned long byteOffset,
                  short value,
                  optional boolean littleEndian);
    void setUint16(unsigned long byteOffset,
                   unsigned short value,
                   optional boolean littleEndian);
    void setInt32(unsigned long byteOffset,
                  long value,
                  optional boolean littleEndian);
    void setUint32(unsigned long byteOffset,
                   unsigned long value,
                   optional boolean littleEndian);
    void setFloat32(unsigned long byteOffset,
                    float value,
                    optional boolean littleEndian);
    void setFloat64(unsigned long byteOffset,
                    double value,
                    optional boolean littleEndian);
};</pre>

    <p>The following constructors, properties, and methods are available on a <tt>DataView</tt>:</p>

    <table class="api">
      <tbody>
	<tr><th colspan="2">Constructors</th></tr>
	<tr>
	  <td><i>DataView</i>(ArrayBuffer buffer, optional unsigned long byteOffset, optional unsigned long byteLength)</td>
	  <td>
	  </td>
	</tr>
	<tr></tr>
	<tr><th colspan="2">Properties</th></tr>
	<tr><td colspan="2"><i>None</i></td></tr>
	<tr></tr>
	<tr><th colspan="2">Methods</th></tr>
	<tr>
	  <td valign="top">
            byte <i>getInt8</i>(unsigned long byteOffset);<br>
            unsigned byte <i>getUInt8</i>(unsigned long byteOffset);<br>
            short <i>getInt16</i>(unsigned long byteOffset, optional boolean littleEndian);<br>
            unsigned short <i>getUInt16</i>(unsigned long byteOffset, optional boolean littleEndian);<br>
            long <i>getInt32</i>(unsigned long byteOffset, optional boolean littleEndian);<br>
            unsigned long <i>getUInt32</i>(unsigned long byteOffset, optional boolean littleEndian);<br>
            float <i>getFloat32</i>(unsigned long byteOffset, optional boolean littleEndian);<br>
            double <i>getFloat64</i>(unsigned long byteOffset, optional boolean littleEndian);<br>
	  </td>
	  <td>
	  </td>
	</tr>
	<tr>
	  <td valign="top">
            void <i>setInt8</i>(unsigned long byteOffset, byte value, optional boolean littleEndian);<br>
            void <i>setUint8</i>(unsigned long byteOffset, unsigned byte value, optional boolean littleEndian);<br>
            void <i>setInt16</i>(unsigned long byteOffset, short value, optional boolean littleEndian);<br>
            void <i>setUint16</i>(unsigned long byteOffset, unsigned short value, optional boolean littleEndian);<br>
            void <i>setInt32</i>(unsigned long byteOffset, long value, optional boolean littleEndian);<br>
            void <i>setUint32</i>(unsigned long byteOffset, unsigned long value, optional boolean littleEndian);<br>
            void <i>setFloat32</i>(unsigned long byteOffset, float value, optional boolean littleEndian);<br>
            void <i>setFloat64</i>(unsigned long byteOffset, double value, optional boolean littleEndian);<br>
	  </td>
	  <td>
	  </td>
	</tr>
      </tbody>
    </table>

    <h2>Outstanding Issues & Bikeshedding</h2>

    <dt>Should <tt>slice()</tt> return a copy or a reference?</dt>
    <dd>
      <p>Right now, <tt>slice()</tt> returns a new <i>TypedArray</i>, but
      it references the same <tt>ArrayBuffer</tt>.  This is useful for
      working with a large chunk of data, but only wanting to pass a
      subregion to a method.  However, the opposite is also useful --
      you may want to make a copy of a segment in order to modify it.
      Right now, that requires a call like: <tt>new
      Int8Array(otherArray.slice(1,10));</tt>.</p>
      <p>Perhaps we want to
      introduce a <tt>subset()</tt> that will be the same behaviour as
      slice currently, and have <tt>slice()</tt> return
      a <i>TypedArray</i> with a new <tt>ArrayBuffer</tt>?</p>
    </dd>

    <dt>There's no good way to copy or subset <tt>ArrayBuffers</tt></dt>
    <dd>
      <p><tt>ArrayBuffer</tt> could use a method to copy a region; perhaps just a new constructor:</p>
      <p><tt>ArrayBuffer(other, [start, [end]])</tt> to copy <tt>start..end</tt> (same arg style as slice()) from <tt>other</tt>.</p>
    </dd>

    <h2>References</h2>
    <dt id="refsWEBIDL">[WEBIDL]</dt>
    <dd><a href="http://dev.w3.org/2006/webapi/WebIDL/">Web IDL</a></dd>

    <dt id="refsWEBGL">[WEBGL]</dt>
    <dd><a href="http://www.webgl.org/">Khronos WebGL Specification</a></dd>

    <dt id="refsFILE">[FILEAPI]</dt>
    <dd><a href="http://www.w3.org/TR/FileAPI/">File API</a></dd>

    <dt id="refsWEBSOCKETS">[WEBSOCKETS]</dt>
    <dd><a href="http://dev.w3.org/html5/websockets/">The Web Sockets API</a></dd>

</body>

</html>
