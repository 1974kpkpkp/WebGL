<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>WebGL Specification</title>
    <meta name="generator" content="BBEdit 9.1">
    <link rel="stylesheet" type="text/css" href="Khronos-WD.css" />
    <link rel="stylesheet" type="text/css" href="default.css" />
    <script src="jquery-1.3.2.min.js" type="text/javascript"></script>
    <script src="generateTOC.js" type="text/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class=head>
        <p>
            <a href="http://khronos.org/">
                <img alt=Khronos height=60 src="KhronosGroup-3D.png" width=220>
            </a>
        </p>
    </div>
    <div class=head>
        <p>
            <a href="http://webgl.org/">
                <img alt=WebGL height=72 src="WebGL-Logo.png" width=156>
            </a>
        </p>
    </div>
    <!--end-logo-->
    
    <h1>WebGL Specification</h1>
    <h2 class="no-toc">Working Draft 26 April 2010</h2>
    <dl>
        <dt>This version:
            <dd>
                <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/WebGL-spec.html">
                    https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/WebGL-spec.html
                </a>
                <br>
                <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl">
                    <b>WebIDL:</b> https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl
                </a>
            </dd>
        <dt>Latest version:
            <dd>
                <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/WebGL-spec.html">
                    https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/WebGL-spec.html
                </a>
                <br>
                <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl">
                    <b>WebIDL:</b> https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/webgl.idl
                </a>
            </dd>
        <dt>Previous version:
            <dd>
                    none
            </dd>
        <dt>Editor:
            <dd>
                <a href="mailto:cmarrin@apple.com">Chris Marrin</a>
                <a href="http://www.apple.com/">(Apple Inc.)</a>
            </dd>
    </dl>

    <hr />
    
    <h2 class="no-toc">Abstract</h2>
    <p>
        This specification describes an additional rendering context and support
        objects for the
        <a
            href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html"
            title="HTML 5 Canvas Element">
            HTML 5 <span class="prop-name">canvas</span> element.
        </a>
        This context allows rendering using an API that conforms closely to the OpenGL ES 2.0 API.
    </p>

    <h2 class="no-toc">Status of this document</h2>
    
    <!--begin-status-->
    <p>
        This is a working draft document and may be updated, replaced or obsoleted 
        by other documents at any time. Do not cite this document 
        as other than work in progress.  Public discussion of this draft specification 
        is welcome on the (<a
            href="https://www.khronos.org/webgl/public-mailing-list/archives/">archived</a>) 
        WebGL mailing list <a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a> (see
        <a href="http://www.khronos.org/webgl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->
    
    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>
    <p>
        <em>This section is not normative.</em>
    </p>

    <p>
        The HTMLCanvasElement places an element on the page into which graphic
        images can be rendered using a programmatic interface. Currently the only
        such interface described is the CanvasRenderingContext2D. This document
        describes another such interface, WebGLRenderingContext, which presents
        an API derived from the OpenGL ES 2.0 specification. This API provides a
        rich set of functions allowing realistic 3D graphics to be rendered.
    </p>
    <p>
        More details needed here...
    </p>

    <div class=issue>
        <p>
            This is where issues would go
        </p>
    </div>

<!-- ======================================================================================================= -->

    <h2>Context Creation and Drawing Buffer Presentation</h2>

    <p>
        Before using the WebGL API, the author must obtain a WebGLRenderingContext object
        for a given HTMLCanvasElement as described below. This object is used to manage 
        OpenGL state and render to the drawing buffer, which must also be created at the time of
        context creation. The author may supply configuration options for this drawing buffer, otherwise
        default values shall be used as specified elsewhere in this document. This drawing buffer
        is presented to the HTML page compositor immediately before an HTML page compositing operation, 
        but only if the drawing buffer has been modified since the last compositing operation.
    </p>
    
<!-- ======================================================================================================= -->

    <h3>The <span class=prop-name>&lsquo;<code class=property>canvas</code>&rsquo;</span> Element</h3>

    <p>
        A WebGLRenderingContext object shall be created by calling the getContext() method of 
        a given HTMLCanvasElement object with the exact string &lsquo;<code class=property>webgl</code>&rsquo;. 
        This string is case sensitive. When called for the first time, a 
        WebGLRenderingContext object is created and returned. Also at this time a drawing buffer
        shall be created. Subsequent calls to getContext() with the same string shall return the same object. 
        If getContext() is subsequently called with any other string, the WebGLRenderingContext shall 
        be detached from its Canvas object (the <code>canvas</code> attribute will be null). API calls may
        still be made on the WebGLRenderingContext object and readPixels() may be used
        to obtain the contents of the drawing buffer, but the contents shall no longer be shown
        on the page.
    </p>
        A second parameter may be passed to the getContext() function. If passed, this parameter 
        shall be a WebGLContextAttributes object containing configuration parameters to be used in 
        creating the drawing buffer. See <a href="#5.2">section 5.2</a> for more details. On subsequent 
        calls to getContext() with the &lsquo;<code class=property>webgl</code>&rsquo; string, the passed
        WebGLContextAttributes object, if any, shall be ignored.
    <p>
    </p>
    
<!-- ======================================================================================================= -->

    <h3>The Drawing Buffer</h3>

    <p>
        The drawing buffer into which the API calls are rendered shall be defined upon creation of
        the WebGLRenderingContext object. The size of this drawing buffer shall be determined by the
        <code>width</code> and <code>height</code> attributes of the HTMLCanvasElement. Changing
        either of these attributes shall cause the drawing buffer to resize and its contents to be
        cleared to (0,0,0,0).
    </p>
    <p>
        By default, the drawing buffer has an RGBA color buffer of at least 8 bits per component 
        and an integer depth buffer of at least 16 bits. The optional WebGLContextAttributes 
        object may be used to change these defaults. This object is only used on the first call
        to getContext. No facility is provided to change the attributes of the drawing buffer 
        after its creation.
    </p>
    <p>
        WebGL presents its drawing buffer to the HTML page compositor immediately before a compositing 
        operation, but only if the drawing buffer has been modified since the last compositing operation.
        Before the drawing buffer is presented for compositing the implementation shall ensure that all 
        rendering operations have been flushed to the drawing buffer. After compositing the contents of 
        the drawing buffer shall be undefined but must not contain uninitialized pixels.
    </p>
    
<!-- ======================================================================================================= -->

    <h3>The WebGL Viewport</h3>

    <p>
        OpenGL manages a rectangular viewport as part of its state which defines the placement of the
        rendering results in the drawing buffer. Upon creation of the WebGL context, the viewport is
        initialized to a rectangle with origin at (0, 0) and width and height equal to (canvas.width,
        canvas.height).
    </p>
    <p>
        A WebGL implementation <em>shall not</em> affect the state of the OpenGL viewport in response to
        resizing of the canvas element.
    </p>
    <div class="example">
        Note that if a WebGL program does not contain logic to set the viewport, it will not properly
        handle the case where the canvas is resized. The following ECMAScript example illustrates how
        a WebGL program might resize the canvas programmatically.

        <pre>
var canvas = document.getElementById('canvas1');
var gl = canvas.getContext('webgl');
canvas.width = newWidth;
canvas.height = newHeight;
gl.viewport(0, 0, canvas.width, canvas.height);
        </pre>
    </div>
    <p>
        <em>Rationale</em>: automatically setting the viewport will interfere with applications that set
        it manually. Applications are expected to use <code>onresize</code> handlers to respond to
        changes in size of the canvas and set the OpenGL viewport in turn.
    </p>

<!-- ======================================================================================================= -->

    <h2>WebGL Resources</h2>

    <p> 
        OpenGL manages several type of resources as part of its state. These are identified
        by integer object names and are obtained from OpenGL by various creation calls.
        In contrast WebGL represents these resources as DOM objects. Each object is derived 
        from the WebGLObject interface. Currently supported resources are:
        textures, buffers (i.e., VBOs) framebuffers, renderbuffers, shaders and
        programs. The WebGLRenderingContext interface has a method to create a 
        WebGLObject subclass for each type. Data from the underlying graphics library are
        stored in these objects and are fully managed by them. The resources represented
        by these objects are guaranteed to exist as long as the object exists.
        Furthermore, the DOM object is guaranteed to exist as long as the author has an explicit
        valid reference to it OR as long as it is bound by the underlying graphics library.
        When none of these conditions exist the user agent can, at any point, delete the object 
        using the equivalent of a delete call (e.g., deleteTexture). If authors wishes to control 
        when the underlying resource is released then the delete call can be made explicitly.
    </p>

<!-- ======================================================================================================= -->

    <h2>Security</h2>

    <p> 
    </p>

<!-- ======================================================================================================= -->

    <h3>WebGLArrayBuffer and Uninitialized Data</h3>

    <p>
        Data present in a <a href="#WebGLArrayBuffer">WebGLArrayBuffer</a> can be read by the application directly 
        by creating a <a href="#WebGLArray">WebGLArray</a> view of the data or indirectly by via rendering 
        and using a method such as <code>readPixels</code>.  At creation time, a WebGLArrayBuffer 
        must be initialized from existing user data or must be cleared to 0.  
        Additionally, the WebGL implementation must ensure that no data outside of 
        the valid byte range for a WebGLArrayBuffer can be accessed.  If a caller 
        attempts to access any data outside of that range, an implementation may 
        choose to raise an exception, use the closest valid index, use 0, or any 
        other approach that prevents it from providing access to uninitialized data.
    </p>

<!-- ======================================================================================================= -->

    <h3>Resource Restrictions</h3>

    <p>
        WebGL resources such as textures and vertex buffer objects (VBOs) must always 
        contain initialized data, even if they were created without initial user 
        data values.  Creating a resource without initial values is commonly used to 
        reserve space for a texture or VBO, which is then modified using <code>texSubImage</code> or 
        <code>bufferSubData</code> calls.  If initial data is not provided to these calls, 
        the WebGL implementation must initialize their contents 
        to 0.  For example, this may require creating a temporary buffer of 0 
        values the size of a requested VBO, so that it can be initialized 
        correctly.  All other forms of loading data into a texture or VBO 
        involve either WebGLArrayBuffers or DOM objects such as images, 
        and are therefore already required to be initialized.
    </p>

    <p>
        When WebGL resources are accessed by shaders through a call such as 
        <code>drawElements</code> or <code>drawArrays</code>, the WebGL implementation must ensure 
        that the shader cannot access either out of bounds or uninitialized 
        data.  For drawArrays, each bound VBO must be at least as large as 
        needed to satisfy the given mode, offset, and count.  For drawElements, 
        the bound index buffer must be at least large enough to satisfy the 
        requested mode, count, type, and offset, and the highest index in the 
        index buffer range must be a valid index for every bound VBO.
    </p>

<!-- ======================================================================================================= -->

    <h3>Origin Restrictions</h3>

    <p>
        In order to prevent information leakage, the HTML5 canvas element has
        a <i>origin-clean</i> flag.  (See HTML5, section 4.8.11.3, "Security with canvas
        elements".)  For a WebGL context, the <i>origin-clean</i> flag must be set to false
        if any of the following actions occur:
    </p>
        <ul>
            <li>The <code>texImage2D</code> method is called with an <code>HTMLImageElement</code> or 
                <code>HTMLVideoElement</code> whose origin is not the same as that of the Document 
                object that owns the canvas element.
            <li>The <code>texImage2D</code> method is called with an <code>HTMLCanvasElement</code> 
                whose <i>origin-clean</i> flag is set to false.
        </ul>
    <p>
        Whenever the <code>readPixels</code> method of the 2D context of a <code>canvas</code> 
        element whose <i>origin-clean</i> flag is set to false is called with otherwise correct 
        arguments, the method must raise a <code>SECURITY_ERR</code> exception.
    </p>

<!-- ======================================================================================================= -->

    <h3>Supported GLSL Constructs</h3>

    <p>
        A WebGL implementation must only accept shaders which conform to The OpenGL ES Shading
        Language, Version 1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a>, and which do not exceed
        the minimum functionality mandated in Sections 4 and 5 of Appendix A.  In particular, a shader
        referencing state variables or functions that are available in other versions of GLSL (such
        as that found in versions of OpenGL for the desktop), must not be allowed to load.
    </p>
    <p>
        In addition to the reserved identifiers in the aforementioned specification, identifiers
        starting with "webgl_" and "_webgl_" are reserved for use by WebGL. A shader which declares
        a function, variable, structure name, or structure field starting with these prefixes must
        not be allowed to load.
    </p>

<!-- ======================================================================================================= -->

    <h3>Defense Against Denial of Service</h3>

    <p>
    <i>This section is non-normative.</i>
    </p>

    <p>
    It is possible to create, either intentionally or unintentionally, combinations of shaders and
    geometry that take an undesirably long time to render. This issue is analogous to that of
    long-running scripts, for which user agents already have safeguards. However, long-running draw
    calls can cause loss of interactivity for the entire window system, not just the user agent.
    </p>

    <p>
    In the general case it is not possible to impose limits on the structure of incoming shaders to
    guard against this problem. Experimentation has shown that even very strict structural limits
    are insufficient to prevent long rendering times, and such limits would prevent shader authors
    from implementing common algorithms.
    </p>

    <p>
    User agents should implement safeguards to prevent excessively long rendering times and
    associated loss of interactivity. Suggested safeguards include:
    </p>

    <ul>

    <li> Splitting up draw calls with large numbers of elements into smaller draw calls.

    <li> Timing individual draw calls and forbidding further rendering from a page if a certain
         timeout is exceeded.

    <li> Using any watchdog facilities available at the user level, graphics API level, or operating
         system level to limit the duration of draw calls.

    <li> Separating the graphics rendering of the user agent into a distinct operating system
         process which can be terminated and restarted without losing application state.

    </ul>

    <p>
    The supporting infrastructure at the OS and graphics API layer is expected to improve over time,
    which is why the exact nature of these safeguards is not specified.
    </p>

<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

<!-- ======================================================================================================= -->

    <h3>Types</h3>

    <p>
        The following types are used in all interfaces in the following section.
    </p>
    <pre class="idl">
typedef events::Event Event;
typedef dom::DOMException DOMException;
typedef html::HTMLCanvasElement HTMLCanvasElement;
typedef html::HTMLImageElement HTMLImageElement;
typedef html::HTMLVideoElement HTMLVideoElement;
typedef html::ImageData ImageData;

typedef unsigned long  GLenum;
typedef boolean        GLboolean;
typedef unsigned long  GLbitfield;
typedef byte           GLbyte;         /* 'byte' should be a signed 8 bit type. */
typedef short          GLshort;
typedef long           GLint;
typedef long           GLsizei;
typedef long           GLsizeiptr;
typedef unsigned byte  GLubyte;        /* 'unsigned byte' should be an unsigned 8 bit type. */
typedef unsigned short GLushort;
typedef unsigned long  GLuint;
typedef float          GLfloat;
typedef float          GLclampf;  
</pre>

<!-- ======================================================================================================= -->

    <h3><a name="WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a></h3>

    <p>
        The <code>WebGLContextAttributes</code> interface contains drawing surface attributes 
        and is passed as the second parameter to getContext. A native object may be supplied
        as this parameter; the specified attributes will be queried from this object.
    </p>
    <pre class="idl">[Callback] interface <dfn id="WebGLContextAttributes">WebGLContextAttributes</dfn> {
    attribute boolean alpha;
    attribute boolean depth;
    attribute boolean stencil;
    attribute boolean antialias;
    attribute boolean premultipliedAlpha;
};</pre>

    <h4>Context creation parameters</h4>

    <p>
        The following list describes each attribute in the WebGLContextAttributes object and
        its use. For each attribute the default value is shown. The default value is used
        either if no second parameter is passed to getContext, or if a native object is passed
        which has no attribute of the given name.
    </p>
    <dl>
        <dt><span class=prop-value>alpha</span></dt>
            <dd>
                <em>Default: true</em>. If the value is true, the drawing buffer has an alpha
                channel for the purposes of performing OpenGL destination alpha operations and
                compositing with the page. If the value is false, no alpha buffer is available.
            </dd>
        <dt> <span class=prop-value>depth</span>
            <dd>
                <em>Default: true</em>. If the value is true, the drawing buffer has a depth
                buffer of at least 16 bits. If the value is false, no depth buffer is
                available.
           </dd>
        <dt> <span class=prop-value>stencil</span>
            <dd>
                <em>Default: true</em>. If the value is true, the drawing buffer has a stencil
                buffer of at least 8 bits. If the value is false, no stencil buffer is
                available.
            </dd>
        <dt> <span class=prop-value>antialias</span>
            <dd>
                <em>Default: true</em>. If the value is true and the implementation supports
                antialiasing the drawing buffer will perform antialiasing using its choice of
                technique (multisample/supersample) and quality. If the value is false or the
                implementation does not support antialiasing, no antialiasing is performed.
            </dd>
        <dt> <span class=prop-value>premultipliedAlpha</span>
            <dd>
                <em>Default: true</em>. If the value is true the page compositor will assume
                the drawing buffer contains colors with premultiplied alpha. If the value is
                false the page compositor will assume that colors in the drawing buffer are not
                premultiplied. This flag is ignored if the <strong>alpha</strong> flag is
                false.
            </dd>
    </dl>

    <div class="example">
    Here is an ECMAScript example which passes a WebGLContextAttributes argument to getContext.
    It assumes the presence of a canvas element named "canvas1" on the page.

    <pre>
var canvas = document.getElementById('canvas1');
var context = canvas.getContext('webgl',
                                { antialias: false,
                                  stencil: false });
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h3>WebGLObject</h3>

    <p>
        The <code>WebGLObject</code> interface is the parent interface for all GL objects.
    </p>
    <pre class="idl">interface <dfn id="WebGLObject">WebGLObject</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLBuffer</h3>

    <p>
        The <code>WebGLBuffer</code> interface represents an OpenGL Buffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenBuffers.xml">
            glGenBuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindBuffer.xml">
        glBindBuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteBuffers.xml">
        glDeleteBuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLBuffer">WebGLBuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLFramebuffer</h3>

    <p>
        The <code>WebGLFramebuffer</code> interface represents an OpenGL Framebuffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenFramebuffers.xml">
            glGenFramebuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindFramebuffer.xml">
        glBindFramebuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteFramebuffers.xml">
        glDeleteFramebuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLFramebuffer">WebGLFramebuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLProgram</h3>

    <p>
        The <code>WebGLProgram</code> interface represents an OpenGL Program Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateProgram.xml">
            glCreateProgram
        </a>
        , used as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUseProgram.xml">
        glUseProgram 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteProgram.xml">
        glDeleteProgram.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLProgram">WebGLProgram</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLRenderbuffer</h3>

    <p>
        The <code>WebGLRenderbuffer</code> interface represents an OpenGL Renderbuffer Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenRenderbuffers.xml">
            glGenRenderbuffers
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindRenderbuffer.xml">
        glBindRenderbuffer 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteRenderbuffers.xml">
        glDeleteRenderbuffers.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderbuffer">WebGLRenderbuffer</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLShader</h3>

    <p>
        The <code>WebGLShader</code> interface represents an OpenGL Shader Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateShader.xml">
            glCreateShader
        </a>
        , attached to a Program as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glAttachShader.xml">
        glAttachShader 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteShader.xml">
        glDeleteShader.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLShader">WebGLShader</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLTexture</h3>

    <p>
        The <code>WebGLTexture</code> interface represents an OpenGL Texture Object. The
        underlying object is created as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenTextures.xml">
            glGenTextures
        </a>
        , bound as if by calling
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindTexture.xml">
        glBindTexture 
        </a>
        and destroyed as if by calling 
        <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteTextures.xml">
        glDeleteTextures.
        </a>
    </p>
    <pre class="idl">interface <dfn id="WebGLTexture">WebGLTexture</dfn> : WebGLObject {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLObjectArray</h3>

    <p>
        The <code>WebGLObjectArray</code> interface represents an array of WebGLObject objects.
    </p>
    <pre class="idl">interface <dfn id="WebGLObjectArray">WebGLObjectArray</dfn> {
    readonly attribute unsigned long length;
    getter WebGLObject get(unsigned long index);
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLUniformLocation</h3>

    <p>
        The <code>WebGLUniformLocation</code> interface represents the location of a uniform variable 
        in a shader program.
    </p>
    <pre class="idl">interface <dfn id="WebGLUniformLocation">WebGLUniformLocation</dfn> {
};</pre>

<!-- ======================================================================================================= -->

    <h3>WebGLActiveInfo</h3>

    <p>
        The <code>WebGLActiveInfo</code> interface represents the information returned 
        from the getActiveAttrib and getActiveUniform calls.
    </p>
    <pre class="idl">interface <dfn id="WebGLActiveInfo">WebGLActiveInfo</dfn> {
    readonly attribute GLint size;
    readonly attribute GLenum type;
    readonly attribute DOMString name;
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-size">
                    size
                </a>
            </code> 
            of type <code>GLint</code>
        <dd>
            The size of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-type">
                    type
                </a>
            </code> 
            of type <code>GLenum</code>
        <dd>
            The data type of the requested variable.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLActiveInfo-name">
                    name
                </a>
            </code> 
            of type <code>DOMString</code>
        <dd>
            The name of the requested variable.
    </dl>

<!-- ======================================================================================================= -->

    <h3>WebGLArrayBuffer</h3>

    <p>
        The <code>WebGLArrayBuffer</code> interface describes the buffer used to store data 
        for the WebGLArray interface and its subclasses.
    </p>
    <pre class="idl">
[ Constructor(unsigned long length) ]
interface <dfn id="WebGLArrayBuffer">WebGLArrayBuffer</dfn> {
    readonly attribute unsigned long byteLength;
};</pre>

    <h4>Constructors</h4>

    <dl class="methods">
        <dt class="idl-code">Constructor(unsigned long length)
        <dd>
            Create a new WebGLArrayBuffer of the passed length in bytes. Data in the buffer is 
            initialized to 0.
    </dl>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArrayBuffer-byteLength">
                    byteLength
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The length of the buffer in bytes.  The length is fixed when the WebGLArrayBuffer is created.
    </dl>
    
<!-- ======================================================================================================= -->

    <h3>WebGLArray</h3>

    <p>
        The <code>WebGLArray</code> interface is the abstract base interface for all the typed array 
        interfaces.  Every <code>WebGLArray</code> subclass presents a typed view of a 
        <a href="#WebGLArrayBuffer">WebGLArrayBuffer</a> region.  Multiple <code>WebGLArray</code>s can 
        reference the same or overlapping regions of a <a href="#WebGLArrayBuffer">WebGLArrayBuffer</a>.
    </p>
    <pre class="idl">
interface <dfn id="WebGLArray">WebGLArray</dfn> {
    readonly attribute WebGLArrayBuffer buffer;
    readonly attribute unsigned long byteOffset;
    readonly attribute unsigned long byteLength;
    readonly attribute unsigned long length;

    WebGLArray slice(long start, long end);
};</pre>

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-buffer">
                    buffer
                </a>
            </code> 
            of type <code>WebGLArrayBuffer</code>
        <dd>
            The WebGLArrayBuffer holding the data for this array.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-byteOffset">
                    byteOffset
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The offset of this data, in bytes, from the start of this <a id="WebGLArray">WebGLArray</a>'s <a id="WebGLArrayBuffer">WebGLArrayBuffer</a>.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-byteLength">
                    byteLength
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The length of this data in bytes.
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-length">
                    length
                </a>
            </code> 
            of type <code>unsigned long</code>
        <dd>
            The length of this data in elements.
    </dl>

    <h4>slice method</h4>

    <dl class="methods">
        <dt class="idl-code">WebGLArray slice(long start, long end)
        <dd>
	  <p>
             Returns a new <a href="#WebGLArray">WebGLArray</a> view
             of the <a href="#WebGLArrayBuffer">WebGLArrayBuffer</a>
             store for this <a href="#WebGLArray">WebGLArray</a>,
             referencing the elements at start, inclusive, up to end,
             exclusive. If either start or end is negative, it refers
             to an index from the end of the array, as opposed to from
             the start. The range specified by the given start and end
             values is clamped to the valid index range for the
             current array, and if not given default to the start and
             end of the array, respectively.
	  </p>
	  <p>
	     The returned <a href="#WebGLArray">WebGLArray</a> will be
	     of the same type as the array on which this method is
	     invoked.
	  </p>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Typed WebGLArray Interfaces</h4>

    <p>
      A <code>WebGLArray</code> is intended to be an abstract base
      interface for WebGLArrays of a specific type.  There is no way
      to create a <code>WebGLArray</code>, but there are constructors
      defined for each of the typed interfaces.  The following
      sections define the shared constructors and methods that each
      typed interface implements.
    </p>
    <p>
      The typed <code>WebGLArray</code> views provide access to data
      using indexing, and also provide a bulk set method for replacing
      a sequence of data from another array.  A summary of all the
      typed <code>WebGLArray</code> views is given in the
      following table.
    </p>

    <center><table>
      <thead>
	<tr><th><i>TypeName</i></th><th>BYTES_PER_ELEMENT</th><th>Type</th><th>Equivalent C Type</th></tr>
      </thead>
      <tbody>
	<tr><td>Byte</td><td>1</td><td>8-bit signed integer</td><td><code>signed char</code></td></tr>
	<tr><td>UnsignedByte</td><td>1</td><td>8-bit unsigned integer</td><td><code>unsigned char</code></td></tr>
	<tr><td>Short</td><td>2</td><td>16-bit signed integer</td><td><code>short</code></td></tr>
	<tr><td>UnsignedShort</td><td>2</td><td>16-bit unsigned integer</td><td><code>unsigned short</code></td></tr>
	<tr><td>Int</td><td>4</td><td>32-bit signed integer</td><td><code>int</code></td></tr>
	<tr><td>UnsignedInt</td><td>4</td><td>32-bit unsigned integer</td><td><code>unsigned int</code></td></tr>
	<tr><td>Float</td><td>4</td><td>32-bit floating point</td><td><code>float</code></td></tr>
      </tbody>
    </table></center>

    <p>
      All of the typed <code>WebGLArray</code> views have the following IDL template:
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGL<i>TypeName</i>Array array),
    Constructor(sequence&lt;<i>type</i>&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface WebGL<i>TypeName</i>Array : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = <i>element size in bytes</i>;
    
    getter <i>type</i> get(unsigned long index);
    setter void set(unsigned long index, <i>type</i> value);
    void set(WebGL<i>TypeName</i>Array array, optional unsigned long offset);
    void set(sequence&lt;<i>type</i>&gt; array, optional unsigned long offset);
};</pre>


    <h5>Shared Constructors</h5>

    <dl class="methods">
        <dt class="idl-code">Constructor(unsigned long length)
        <dd>
            Create a new WebGL<i>TypeName</i>Array object of the given length with a new
            underlying WebGLArrayBuffer large enough to hold <code>length</code>
            elements of the specific type. Data in the buffer is initialized to 0.
        <dt><p class="idl-code">Constructor(WebGL<i>TypeName</i>Array array)</p>
            <p class="idl-code">Constructor(sequence&lt;<i>type</i>&gt; array)</p>
        <dd>
            Create a new WebGL<i>TypeName</i>Array object with a new underlying
            WebGLArrayBuffer large enough to hold the given data, then copy the passed
            data into the buffer.
        <dt class="idl-code">Constructor(WebGLArrayBuffer buffer, optional unsigned long byteOffset, optional unsigned long length)
        <dd>
      <p>
            Create a new WebGL<i>TypeName</i>Array object using the passed
            WebGLArrayBuffer for its storage. Optional byteOffset and length can be used
            to limit the section of the buffer referenced. The byteOffset indicates the
            offset in bytes from the start of the WebGLArrayBuffer, and the length is the
            count of elements from the offset that this WebGLByteArray will reference.
            If both byteOffset and length are omitted, the WebGL<i>TypeName</i>Array
            spans the entire WebGLArrayBuffer range.  If the length is omitted, the
            WebGL<i>TypeName</i>Array extends from the given byteOffset until the end of
            the WebGLArrayBuffer.
      </p>
      <p>
        The given byteOffset must be a multiple of the element size of the specific
        type, otherwise an exception is raised.
      </p>
      <p>
            If the passed WebGLArrayBuffer is null, undefined, or a
            value not convertible to a WebGLArrayBuffer, an exception
            is raised.
      </p>
      <p>
        If a given byteOffset and length references an area beyond the end of the
            WebGLArrayBuffer an exception is raised.
      </p>
    </dl>

    <h5>Shared Constants</h5>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLArray-BYTES_PER_ELEMENT">
                    BYTES_PER_ELEMENT
                </a>
            </code> 
            of type <code>GLsizei</code>
        <dd>
            The size in bytes of each element in the array. This constant is provided to make it easier for
            authors to compute the byte offsets needed for heterogenous arrays. See example
            below.
    </dl>

    <h5>Shared Getters and Setters</h5>

    <dl class="methods">
        <dt class="idl-code"><i>type</i> get(unsigned long index)
        <dd>
      Return the element at the given index.  If the index is out of range, an exception is raised.  
      This is an index getter function, and may be invoked via array index syntax where applicable.
        <dt class="idl-code">void set(unsigned long index, <i>type</i> value)
        <dd>
      <p>
        Sets the element at the given index to the given value.  If the index is out of range, an 
        exception is raised.  This is an index setter function, and may be invoked via array index 
        syntax where applicable.
      </p>
      <p>
        If the given value is out of range for the type of the array, a C-style cast operation is 
        performed to coerce the value to the valid range.  No clamping or rounding is performed.
      </p>
        <dt><p class="idl-code">void set(WebGL<i>TypeName</i>Array array, optional unsigned long offset)</p>
            <p class="idl-code">void set(sequence&lt;<i>type</i>&gt; array, optional unsigned long offset)</p>
        <dd>
      <p>
        Set multiple values, reading input values from the array.  The optional offset
        value indicates the index in the current array where values are written.  If
        omitted, it is assumed to be 0.
      </p>
      <p>
        The input array may be a <code>WebGL<i>TypeName</i>Array</code>, and the two arrays may use
        the same underlying <code>WebGLArrayBuffer</code>. In this situation, setting the values
        takes place as if all the data is first copied into a temporary buffer that does not overlap
        either of the arrays, and then the data from the temporary buffer is copied into the current
        array.
      </p>
      <p>
	If the offset plus the length of the given array is out of
	range for the current <code>WebGLArray</code>, an exception
	is raised.
      </p>
    </dl>

    <div class="example">
    Here is an ECMAScript example showing access to the same WebGLArrayBuffer using
    different types of WebGLArray objects. In this case the buffer contains a
    floating point vertex position (x, y, z) followed by a color as 4 unsigned bytes (r, g, b, a).

    <pre>
var numVertices = 100; // for example

// Compute the size needed for the buffer, in bytes and floats
var vertexSize = 3 * WebGLFloatArray.BYTES_PER_ELEMENT +
     4 * WebGLUnsignedByteArray.BYTES_PER_ELEMENT;
var vertexSizeInFloats = vertexSize / WebGLFloatArray.BYTES_PER_ELEMENT;

// Allocate the buffer
var buf = new WebGLArrayBuffer(numVertices * vertexSize);

// Map this buffer to a WebGLFloatArray to access the positions
var positionArray = new WebGLFloatArray(buf);

// Map the same buffer to a WebGLUnsignedByteArray to access the color
var colorArray = new WebGLUnsignedByteArray(buf);

// Set up the initial offset of the vertices and colors within the buffer
var positionIdx = 0;
var colorIdx = 3 * WebGLFloatArray.BYTES_PER_ELEMENT;

// Initialize the buffer
for (var i = 0; i < numVertices; i++) {
    positionArray[positionIdx] = ...;
    positionArray[positionIdx + 1] = ...;
    positionArray[positionIdx + 2] = ...;
    colorArray[colorIdx] = ...;
    colorArray[colorIdx + 1] = ...;
    colorArray[colorIdx + 2] = ...;
    colorArray[colorIdx + 3] = ...;
    positionIdx += vertexSizeInFloats;
    colorIdx += vertexSize;
}
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h5>WebGLByteArray</h5>

    <p>
      A <code>WebGLByteArray</code> represents an array of 8-bit signed integer values.
    </p>
    <p>
      A <code>WebGLByteArray</code> has an element size of 1 byte.
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGLByteArray array),
    Constructor(sequence&lt;GLbyte&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="WebGLByteArray">WebGLByteArray</dfn> : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = 1;
    
    getter GLbyte get(unsigned long index);
    setter void set(unsigned long index, GLbyte value);
    void set(WebGLByteArray array, optional unsigned long offset);
    void set(sequence&lt;GLbyte&gt; array, optional unsigned long offset);
};</pre>

<!-- ======================================================================================================= -->

    <h5>WebGLUnsignedByteArray</h5>

    <p>
      A <code>WebGLUnsignedByteArray</code> represents an array of 8-bit unsigned integer values.
    </p>
    <p>
      A <code>WebGLUnsignedByteArray</code> has an element size of 1 byte.
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGLUnsignedByteArray array),
    Constructor(sequence&lt;GLubyte&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="WebGLUnsignedByteArray">WebGLUnsignedByteArray</dfn> : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = 1;
    
    getter GLubyte get(unsigned long index);
    setter void set(unsigned long index, GLubyte value);
    void set(WebGLUnsignedByteArray array, optional unsigned long offset);
    void set(sequence&lt;GLubyte&gt; array, optional unsigned long offset);
};</pre>

<!-- ======================================================================================================= -->

    <h5>WebGLShortArray</h5>

    <p>
      A <code>WebGLShortArray</code> represents an array of 16-bit signed integer values.
    </p>
    <p>
      A <code>WebGLShortArray</code> has an element size of 2 bytes.
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGLShortArray array),
    Constructor(sequence&lt;GLshort&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="WebGLShortArray">WebGLShortArray</dfn> : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = 2;
    
    getter GLshort get(unsigned long index);
    setter void set(unsigned long index, GLshort value);
    void set(WebGLShortArray array, optional unsigned long offset);
    void set(sequence&lt;GLshort&gt; array, optional unsigned long offset);
};</pre>

<!-- ======================================================================================================= -->

    <h5>WebGLUnsignedShortArray</h5>

    <p>
      A <code>WebGLUnsignedShortArray</code> represents an array of 16-bit unsigned integer values.
    </p>
    <p>
      A <code>WebGLUnsignedShortArray</code> has an element size of 2 bytes.
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGLUnsignedShortArray array),
    Constructor(sequence&lt;GLushort&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="WebGLUnsignedShortArray">WebGLUnsignedShortArray</dfn> : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = 2;
    
    getter GLushort get(unsigned long index);
    setter void set(unsigned long index, GLushort value);
    void set(WebGLUnsignedShortArray array, optional unsigned long offset);
    void set(sequence&lt;GLushort&gt; array, optional unsigned long offset);
};</pre>


<!-- ======================================================================================================= -->

    <h5>WebGLIntArray</h5>

    <p>
      A <code>WebGLIntArray</code> represents an array of 32-bit signed integer values.
    </p>
    <p>
      A <code>WebGLIntArray</code> has an element size of 4 bytes.
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGLIntArray array),
    Constructor(sequence&lt;GLint&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="WebGLIntArray">WebGLIntArray</dfn> : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = 4;
    
    getter GLint get(unsigned long index);
    setter void set(unsigned long index, GLint value);
    void set(WebGLIntArray array, optional unsigned long offset);
    void set(sequence&lt;GLint&gt; array, optional unsigned long offset);
};</pre>

<!-- ======================================================================================================= -->

    <h5>WebGLUnsignedIntArray</h5>

    <p>
      A <code>WebGLUnsignedIntArray</code> represents an array of 32-bit unsigned integer values.
    </p>
    <p>
      A <code>WebGLUnsignedIntArray</code> has an element size of 4 bytes.
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGLUnsignedIntArray array),
    Constructor(sequence&lt;GLuint&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="WebGLUnsignedIntArray">WebGLUnsignedIntArray</dfn> : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = 4;
    
    getter GLuint get(unsigned long index);
    setter void set(unsigned long index, GLuint value);
    void set(WebGLUnsignedIntArray array, optional unsigned long offset);
    void set(sequence&lt;GLuint&gt; array, optional unsigned long offset);
};</pre>

<!-- ======================================================================================================= -->

    <h5>WebGLFloatArray</h5>

    <p>
      A <code>WebGLFloatArray</code> represents an array of 32-bit floating point values.
    </p>
    <p>
      A <code>WebGLFloatArray</code> has an element size of 4 bytes.
    </p>

    <pre class="idl">
[
    Constructor(unsigned long length),
    Constructor(WebGLFloatArray array),
    Constructor(sequence&lt;GLfloat&gt; array),
    Constructor(WebGLArrayBuffer buffer, 
                optional unsigned long byteOffset, optional unsigned long length)
]
interface <dfn id="WebGLFloatArray">WebGLFloatArray</dfn> : WebGLArray {
    const GLsizei BYTES_PER_ELEMENT = 4;
    
    getter GLfloat get(unsigned long index);
    setter void set(unsigned long index, GLfloat value);
    void set(WebGLFloatArray array, optional unsigned long offset);
    void set(sequence&lt;GLfloat&gt; array, optional unsigned long offset);
};</pre>

<!-- ======================================================================================================= -->

    <h3>The WebGL context</h3>

    <p>
        The <code>WebGLRenderingContext</code> represents the API allowing
        OpenGL ES 2.0 style rendering into the canvas element.
    </p>
    <pre class="idl">interface <dfn id="WebGLRenderingContext">WebGLRenderingContext</dfn> {

    /* ClearBufferMask */
    const GLenum DEPTH_BUFFER_BIT               = 0x00000100;
    const GLenum STENCIL_BUFFER_BIT             = 0x00000400;
    const GLenum COLOR_BUFFER_BIT               = 0x00004000;
    
    /* BeginMode */
    const GLenum POINTS                         = 0x0000;
    const GLenum LINES                          = 0x0001;
    const GLenum LINE_LOOP                      = 0x0002;
    const GLenum LINE_STRIP                     = 0x0003;
    const GLenum TRIANGLES                      = 0x0004;
    const GLenum TRIANGLE_STRIP                 = 0x0005;
    const GLenum TRIANGLE_FAN                   = 0x0006;
    
    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* BlendingFactorDest */
    const GLenum ZERO                           = 0;
    const GLenum ONE                            = 1;
    const GLenum SRC_COLOR                      = 0x0300;
    const GLenum ONE_MINUS_SRC_COLOR            = 0x0301;
    const GLenum SRC_ALPHA                      = 0x0302;
    const GLenum ONE_MINUS_SRC_ALPHA            = 0x0303;
    const GLenum DST_ALPHA                      = 0x0304;
    const GLenum ONE_MINUS_DST_ALPHA            = 0x0305;
    
    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    const GLenum DST_COLOR                      = 0x0306;
    const GLenum ONE_MINUS_DST_COLOR            = 0x0307;
    const GLenum SRC_ALPHA_SATURATE             = 0x0308;
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */
    
    /* BlendEquationSeparate */
    const GLenum FUNC_ADD                       = 0x8006;
    const GLenum BLEND_EQUATION                 = 0x8009;
    const GLenum BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
    const GLenum BLEND_EQUATION_ALPHA           = 0x883D;
    
    /* BlendSubtract */
    const GLenum FUNC_SUBTRACT                  = 0x800A;
    const GLenum FUNC_REVERSE_SUBTRACT          = 0x800B;
    
    /* Separate Blend Functions */
    const GLenum BLEND_DST_RGB                  = 0x80C8;
    const GLenum BLEND_SRC_RGB                  = 0x80C9;
    const GLenum BLEND_DST_ALPHA                = 0x80CA;
    const GLenum BLEND_SRC_ALPHA                = 0x80CB;
    const GLenum CONSTANT_COLOR                 = 0x8001;
    const GLenum ONE_MINUS_CONSTANT_COLOR       = 0x8002;
    const GLenum CONSTANT_ALPHA                 = 0x8003;
    const GLenum ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
    const GLenum BLEND_COLOR                    = 0x8005;
    
    /* Buffer Objects */
    const GLenum ARRAY_BUFFER                   = 0x8892;
    const GLenum ELEMENT_ARRAY_BUFFER           = 0x8893;
    const GLenum ARRAY_BUFFER_BINDING           = 0x8894;
    const GLenum ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;
    
    const GLenum STREAM_DRAW                    = 0x88E0;
    const GLenum STATIC_DRAW                    = 0x88E4;
    const GLenum DYNAMIC_DRAW                   = 0x88E8;
    
    const GLenum BUFFER_SIZE                    = 0x8764;
    const GLenum BUFFER_USAGE                   = 0x8765;
    
    const GLenum CURRENT_VERTEX_ATTRIB          = 0x8626;
    
    /* CullFaceMode */
    const GLenum FRONT                          = 0x0404;
    const GLenum BACK                           = 0x0405;
    const GLenum FRONT_AND_BACK                 = 0x0408;
    
    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* EnableCap */
    /* TEXTURE_2D */
    const GLenum CULL_FACE                      = 0x0B44;
    const GLenum BLEND                          = 0x0BE2;
    const GLenum DITHER                         = 0x0BD0;
    const GLenum STENCIL_TEST                   = 0x0B90;
    const GLenum DEPTH_TEST                     = 0x0B71;
    const GLenum SCISSOR_TEST                   = 0x0C11;
    const GLenum POLYGON_OFFSET_FILL            = 0x8037;
    const GLenum SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
    const GLenum SAMPLE_COVERAGE                = 0x80A0;
    
    /* ErrorCode */
    const GLenum NO_ERROR                       = 0;
    const GLenum INVALID_ENUM                   = 0x0500;
    const GLenum INVALID_VALUE                  = 0x0501;
    const GLenum INVALID_OPERATION              = 0x0502;
    const GLenum OUT_OF_MEMORY                  = 0x0505;
    
    /* FrontFaceDirection */
    const GLenum CW                             = 0x0900;
    const GLenum CCW                            = 0x0901;
    
    /* GetPName */
    const GLenum LINE_WIDTH                     = 0x0B21;
    const GLenum ALIASED_POINT_SIZE_RANGE       = 0x846D;
    const GLenum ALIASED_LINE_WIDTH_RANGE       = 0x846E;
    const GLenum CULL_FACE_MODE                 = 0x0B45;
    const GLenum FRONT_FACE                     = 0x0B46;
    const GLenum DEPTH_RANGE                    = 0x0B70;
    const GLenum DEPTH_WRITEMASK                = 0x0B72;
    const GLenum DEPTH_CLEAR_VALUE              = 0x0B73;
    const GLenum DEPTH_FUNC                     = 0x0B74;
    const GLenum STENCIL_CLEAR_VALUE            = 0x0B91;
    const GLenum STENCIL_FUNC                   = 0x0B92;
    const GLenum STENCIL_FAIL                   = 0x0B94;
    const GLenum STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
    const GLenum STENCIL_PASS_DEPTH_PASS        = 0x0B96;
    const GLenum STENCIL_REF                    = 0x0B97;
    const GLenum STENCIL_VALUE_MASK             = 0x0B93;
    const GLenum STENCIL_WRITEMASK              = 0x0B98;
    const GLenum STENCIL_BACK_FUNC              = 0x8800;
    const GLenum STENCIL_BACK_FAIL              = 0x8801;
    const GLenum STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
    const GLenum STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
    const GLenum STENCIL_BACK_REF               = 0x8CA3;
    const GLenum STENCIL_BACK_VALUE_MASK        = 0x8CA4;
    const GLenum STENCIL_BACK_WRITEMASK         = 0x8CA5;
    const GLenum VIEWPORT                       = 0x0BA2;
    const GLenum SCISSOR_BOX                    = 0x0C10;
    /*      SCISSOR_TEST */
    const GLenum COLOR_CLEAR_VALUE              = 0x0C22;
    const GLenum COLOR_WRITEMASK                = 0x0C23;
    const GLenum UNPACK_ALIGNMENT               = 0x0CF5;
    const GLenum PACK_ALIGNMENT                 = 0x0D05;
    const GLenum MAX_TEXTURE_SIZE               = 0x0D33;
    const GLenum MAX_VIEWPORT_DIMS              = 0x0D3A;
    const GLenum SUBPIXEL_BITS                  = 0x0D50;
    const GLenum RED_BITS                       = 0x0D52;
    const GLenum GREEN_BITS                     = 0x0D53;
    const GLenum BLUE_BITS                      = 0x0D54;
    const GLenum ALPHA_BITS                     = 0x0D55;
    const GLenum DEPTH_BITS                     = 0x0D56;
    const GLenum STENCIL_BITS                   = 0x0D57;
    const GLenum POLYGON_OFFSET_UNITS           = 0x2A00;
    /*      POLYGON_OFFSET_FILL */
    const GLenum POLYGON_OFFSET_FACTOR          = 0x8038;
    const GLenum TEXTURE_BINDING_2D             = 0x8069;
    const GLenum SAMPLE_BUFFERS                 = 0x80A8;
    const GLenum SAMPLES                        = 0x80A9;
    const GLenum SAMPLE_COVERAGE_VALUE          = 0x80AA;
    const GLenum SAMPLE_COVERAGE_INVERT         = 0x80AB;
    
    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */
    
    const GLenum NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
    const GLenum COMPRESSED_TEXTURE_FORMATS     = 0x86A3;
    
    /* HintMode */
    const GLenum DONT_CARE                      = 0x1100;
    const GLenum FASTEST                        = 0x1101;
    const GLenum NICEST                         = 0x1102;
    
    /* HintTarget */
    const GLenum GENERATE_MIPMAP_HINT            = 0x8192;
    
    /* DataType */
    const GLenum BYTE                           = 0x1400;
    const GLenum UNSIGNED_BYTE                  = 0x1401;
    const GLenum SHORT                          = 0x1402;
    const GLenum UNSIGNED_SHORT                 = 0x1403;
    const GLenum INT                            = 0x1404;
    const GLenum UNSIGNED_INT                   = 0x1405;
    const GLenum FLOAT                          = 0x1406;
    
    /* PixelFormat */
    const GLenum DEPTH_COMPONENT                = 0x1902;
    const GLenum ALPHA                          = 0x1906;
    const GLenum RGB                            = 0x1907;
    const GLenum RGBA                           = 0x1908;
    const GLenum LUMINANCE                      = 0x1909;
    const GLenum LUMINANCE_ALPHA                = 0x190A;
    
    /* PixelType */
    /*      UNSIGNED_BYTE */
    const GLenum UNSIGNED_SHORT_4_4_4_4         = 0x8033;
    const GLenum UNSIGNED_SHORT_5_5_5_1         = 0x8034;
    const GLenum UNSIGNED_SHORT_5_6_5           = 0x8363;
    
    /* Shaders */
    const GLenum FRAGMENT_SHADER                  = 0x8B30;
    const GLenum VERTEX_SHADER                    = 0x8B31;
    const GLenum MAX_VERTEX_ATTRIBS               = 0x8869;
    const GLenum MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
    const GLenum MAX_VARYING_VECTORS              = 0x8DFC;
    const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
    const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
    const GLenum MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
    const GLenum MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
    const GLenum SHADER_TYPE                      = 0x8B4F;
    const GLenum DELETE_STATUS                    = 0x8B80;
    const GLenum LINK_STATUS                      = 0x8B82;
    const GLenum VALIDATE_STATUS                  = 0x8B83;
    const GLenum ATTACHED_SHADERS                 = 0x8B85;
    const GLenum ACTIVE_UNIFORMS                  = 0x8B86;
    const GLenum ACTIVE_UNIFORM_MAX_LENGTH        = 0x8B87;
    const GLenum ACTIVE_ATTRIBUTES                = 0x8B89;
    const GLenum ACTIVE_ATTRIBUTE_MAX_LENGTH      = 0x8B8A;
    const GLenum SHADING_LANGUAGE_VERSION         = 0x8B8C;
    const GLenum CURRENT_PROGRAM                  = 0x8B8D;
    
    /* StencilFunction */
    const GLenum NEVER                          = 0x0200;
    const GLenum LESS                           = 0x0201;
    const GLenum EQUAL                          = 0x0202;
    const GLenum LEQUAL                         = 0x0203;
    const GLenum GREATER                        = 0x0204;
    const GLenum NOTEQUAL                       = 0x0205;
    const GLenum GEQUAL                         = 0x0206;
    const GLenum ALWAYS                         = 0x0207;
    
    /* StencilOp */
    /*      ZERO */
    const GLenum KEEP                           = 0x1E00;
    const GLenum REPLACE                        = 0x1E01;
    const GLenum INCR                           = 0x1E02;
    const GLenum DECR                           = 0x1E03;
    const GLenum INVERT                         = 0x150A;
    const GLenum INCR_WRAP                      = 0x8507;
    const GLenum DECR_WRAP                      = 0x8508;
    
    /* StringName */
    const GLenum VENDOR                         = 0x1F00;
    const GLenum RENDERER                       = 0x1F01;
    const GLenum VERSION                        = 0x1F02;
    const GLenum EXTENSIONS                     = 0x1F03;
    
    /* TextureMagFilter */
    const GLenum NEAREST                        = 0x2600;
    const GLenum LINEAR                         = 0x2601;
    
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    const GLenum NEAREST_MIPMAP_NEAREST         = 0x2700;
    const GLenum LINEAR_MIPMAP_NEAREST          = 0x2701;
    const GLenum NEAREST_MIPMAP_LINEAR          = 0x2702;
    const GLenum LINEAR_MIPMAP_LINEAR           = 0x2703;
    
    /* TextureParameterName */
    const GLenum TEXTURE_MAG_FILTER             = 0x2800;
    const GLenum TEXTURE_MIN_FILTER             = 0x2801;
    const GLenum TEXTURE_WRAP_S                 = 0x2802;
    const GLenum TEXTURE_WRAP_T                 = 0x2803;
    
    /* TextureTarget */
    const GLenum TEXTURE_2D                     = 0x0DE1;
    const GLenum TEXTURE                        = 0x1702;
    
    const GLenum TEXTURE_CUBE_MAP               = 0x8513;
    const GLenum TEXTURE_BINDING_CUBE_MAP       = 0x8514;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
    const GLenum MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;
    
    /* TextureUnit */
    const GLenum TEXTURE0                       = 0x84C0;
    const GLenum TEXTURE1                       = 0x84C1;
    const GLenum TEXTURE2                       = 0x84C2;
    const GLenum TEXTURE3                       = 0x84C3;
    const GLenum TEXTURE4                       = 0x84C4;
    const GLenum TEXTURE5                       = 0x84C5;
    const GLenum TEXTURE6                       = 0x84C6;
    const GLenum TEXTURE7                       = 0x84C7;
    const GLenum TEXTURE8                       = 0x84C8;
    const GLenum TEXTURE9                       = 0x84C9;
    const GLenum TEXTURE10                      = 0x84CA;
    const GLenum TEXTURE11                      = 0x84CB;
    const GLenum TEXTURE12                      = 0x84CC;
    const GLenum TEXTURE13                      = 0x84CD;
    const GLenum TEXTURE14                      = 0x84CE;
    const GLenum TEXTURE15                      = 0x84CF;
    const GLenum TEXTURE16                      = 0x84D0;
    const GLenum TEXTURE17                      = 0x84D1;
    const GLenum TEXTURE18                      = 0x84D2;
    const GLenum TEXTURE19                      = 0x84D3;
    const GLenum TEXTURE20                      = 0x84D4;
    const GLenum TEXTURE21                      = 0x84D5;
    const GLenum TEXTURE22                      = 0x84D6;
    const GLenum TEXTURE23                      = 0x84D7;
    const GLenum TEXTURE24                      = 0x84D8;
    const GLenum TEXTURE25                      = 0x84D9;
    const GLenum TEXTURE26                      = 0x84DA;
    const GLenum TEXTURE27                      = 0x84DB;
    const GLenum TEXTURE28                      = 0x84DC;
    const GLenum TEXTURE29                      = 0x84DD;
    const GLenum TEXTURE30                      = 0x84DE;
    const GLenum TEXTURE31                      = 0x84DF;
    const GLenum ACTIVE_TEXTURE                 = 0x84E0;
    
    /* TextureWrapMode */
    const GLenum REPEAT                         = 0x2901;
    const GLenum CLAMP_TO_EDGE                  = 0x812F;
    const GLenum MIRRORED_REPEAT                = 0x8370;
    
    /* Uniform Types */
    const GLenum FLOAT_VEC2                     = 0x8B50;
    const GLenum FLOAT_VEC3                     = 0x8B51;
    const GLenum FLOAT_VEC4                     = 0x8B52;
    const GLenum INT_VEC2                       = 0x8B53;
    const GLenum INT_VEC3                       = 0x8B54;
    const GLenum INT_VEC4                       = 0x8B55;
    const GLenum BOOL                           = 0x8B56;
    const GLenum BOOL_VEC2                      = 0x8B57;
    const GLenum BOOL_VEC3                      = 0x8B58;
    const GLenum BOOL_VEC4                      = 0x8B59;
    const GLenum FLOAT_MAT2                     = 0x8B5A;
    const GLenum FLOAT_MAT3                     = 0x8B5B;
    const GLenum FLOAT_MAT4                     = 0x8B5C;
    const GLenum SAMPLER_2D                     = 0x8B5E;
    const GLenum SAMPLER_CUBE                   = 0x8B60;
    
    /* Vertex Arrays */
    const GLenum VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
    const GLenum VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
    const GLenum VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
    const GLenum VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
    const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
    const GLenum VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
    const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
    
    /* Read Format */
    const GLenum IMPLEMENTATION_COLOR_READ_TYPE   = 0x8B9A;
    const GLenum IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
    
    /* Shader Source */
    const GLenum COMPILE_STATUS                 = 0x8B81;
    const GLenum INFO_LOG_LENGTH                = 0x8B84;
    const GLenum SHADER_SOURCE_LENGTH           = 0x8B88;
    const GLenum SHADER_COMPILER                = 0x8DFA;
    
    /* Shader Precision-Specified Types */
    const GLenum LOW_FLOAT                      = 0x8DF0;
    const GLenum MEDIUM_FLOAT                   = 0x8DF1;
    const GLenum HIGH_FLOAT                     = 0x8DF2;
    const GLenum LOW_INT                        = 0x8DF3;
    const GLenum MEDIUM_INT                     = 0x8DF4;
    const GLenum HIGH_INT                       = 0x8DF5;
    
    /* Framebuffer Object. */
    const GLenum FRAMEBUFFER                    = 0x8D40;
    const GLenum RENDERBUFFER                   = 0x8D41;
    
    const GLenum RGBA4                          = 0x8056;
    const GLenum RGB5_A1                        = 0x8057;
    const GLenum RGB565                         = 0x8D62;
    const GLenum DEPTH_COMPONENT16              = 0x81A5;
    const GLenum STENCIL_INDEX                  = 0x1901;
    const GLenum STENCIL_INDEX8                 = 0x8D48;
    const GLenum DEPTH_STENCIL                  = 0x84F9;
    
    const GLenum RENDERBUFFER_WIDTH             = 0x8D42;
    const GLenum RENDERBUFFER_HEIGHT            = 0x8D43;
    const GLenum RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
    const GLenum RENDERBUFFER_RED_SIZE          = 0x8D50;
    const GLenum RENDERBUFFER_GREEN_SIZE        = 0x8D51;
    const GLenum RENDERBUFFER_BLUE_SIZE         = 0x8D52;
    const GLenum RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
    const GLenum RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
    const GLenum RENDERBUFFER_STENCIL_SIZE      = 0x8D55;
    
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
    const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
    const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
    
    const GLenum COLOR_ATTACHMENT0              = 0x8CE0;
    const GLenum DEPTH_ATTACHMENT               = 0x8D00;
    const GLenum STENCIL_ATTACHMENT             = 0x8D20;
    const GLenum DEPTH_STENCIL_ATTACHMENT       = 0x821A;
    
    const GLenum NONE                           = 0;
    
    const GLenum FRAMEBUFFER_COMPLETE                      = 0x8CD5;
    const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
    const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
    const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
    const GLenum FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;
    
    const GLenum FRAMEBUFFER_BINDING            = 0x8CA6;
    const GLenum RENDERBUFFER_BINDING           = 0x8CA7;
    const GLenum MAX_RENDERBUFFER_SIZE          = 0x84E8;
    
    const GLenum INVALID_FRAMEBUFFER_OPERATION  = 0x0506;
    
    readonly attribute HTMLCanvasElement canvas;

    WebGLContextAttributes getContextAttributes();

    boolean isContextLost();
    boolean resetContext();
    
    DOMString[ ] getSupportedExtensions();
    object getExtension(DOMString name);

    void activeTexture(GLenum texture) raises(DOMException);
    void attachShader(WebGLProgram program, WebGLShader shader) raises(DOMException);
    void bindAttribLocation(WebGLProgram program, GLuint index, DOMString name) 
                                                                        raises(DOMException);
    void bindBuffer(GLenum target, WebGLBuffer buffer) raises(DOMException);
    void bindFramebuffer(GLenum target, WebGLFramebuffer framebuffer) 
                                                                        raises(DOMException);
    void bindRenderbuffer(GLenum target, WebGLRenderbuffer renderbuffer) 
                                                                        raises(DOMException);
    void bindTexture(GLenum target, WebGLTexture texture) raises(DOMException);
    void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) 
                                                                        raises(DOMException);
    void blendEquation(GLenum mode) raises(DOMException);
    void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) raises(DOMException);
    void blendFunc(GLenum sfactor, GLenum dfactor) raises(DOMException);
    void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, 
                           GLenum srcAlpha, GLenum dstAlpha) raises(DOMException);

    void bufferData(GLenum target, GLsizei size, GLenum usage) raises(DOMException);
    void bufferData(GLenum target, WebGLArray data, GLenum usage) 
                                                                        raises(DOMException);
    void bufferData(GLenum target, WebGLArrayBuffer data, GLenum usage) 
                                                                        raises(DOMException);
    void bufferSubData(GLenum target, GLsizeiptr offset, WebGLArray data) 
                                                                        raises(DOMException);
    void bufferSubData(GLenum target, GLsizeiptr offset, WebGLArrayBuffer data) 
                                                                        raises(DOMException);

    GLenum checkFramebufferStatus(GLenum target) raises(DOMException);
    void clear(GLbitfield mask) raises(DOMException);
    void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) 
                                                                        raises(DOMException);
    void clearDepth(GLclampf depth) raises(DOMException);
    void clearStencil(GLint s) raises(DOMException);
    void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
                                                                        raises(DOMException);
    void compileShader(WebGLShader shader) raises(DOMException);

    void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, 
                        GLint x, GLint y, GLsizei width, GLsizei height, 
                        GLint border) raises(DOMException);
    void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                           GLint x, GLint y, GLsizei width, GLsizei height) 
                                                                        raises(DOMException);

    WebGLBuffer createBuffer() raises(DOMException);
    WebGLFramebuffer createFramebuffer() raises(DOMException);
    WebGLProgram createProgram() raises(DOMException);
    WebGLRenderbuffer createRenderbuffer() raises(DOMException);
    WebGLShader createShader(GLenum type) raises(DOMException);
    WebGLTexture createTexture() raises(DOMException);

    void cullFace(GLenum mode) raises(DOMException);

    void deleteBuffer(WebGLBuffer buffer) raises(DOMException);
    void deleteFramebuffer(WebGLFramebuffer framebuffer) raises(DOMException);
    void deleteProgram(WebGLProgram program) raises(DOMException);
    void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) raises(DOMException);
    void deleteShader(WebGLShader shader) raises(DOMException);
    void deleteTexture(WebGLTexture texture) raises(DOMException);

    void depthFunc(GLenum func) raises(DOMException);
    void depthMask(GLboolean flag) raises(DOMException);
    void depthRange(GLclampf zNear, GLclampf zFar) raises(DOMException);
    void detachShader(WebGLProgram program, WebGLShader shader) raises(DOMException);
    void disable(GLenum cap) raises(DOMException);
    void disableVertexAttribArray(GLuint index) raises(DOMException);
    void drawArrays(GLenum mode, GLint first, GLsizei count) raises(DOMException);
    void drawElements(GLenum mode, GLsizei count, GLenum type, GLsizeiptr offset) 
                                                                        raises(DOMException);

    void enable(GLenum cap) raises(DOMException);
    void enableVertexAttribArray(GLuint index) raises(DOMException);
    void finish() raises(DOMException);
    void flush() raises(DOMException);
    void framebufferRenderbuffer(GLenum target, GLenum attachment, 
                                 GLenum renderbuffertarget, 
                                 WebGLRenderbuffer renderbuffer) raises(DOMException);
    void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, 
                              WebGLTexture texture, GLint level) raises(DOMException);
    void frontFace(GLenum mode) raises(DOMException);

    void generateMipmap(GLenum target) raises(DOMException);

    WebGLActiveInfo getActiveAttrib(GLuint program, GLuint index) raises(DOMException);
    WebGLActiveInfo getActiveUniform(GLuint program, GLuint index) raises(DOMException);
    WebGLObjectArray getAttachedShaders(GLuint program) raises(DOMException);

    GLint getAttribLocation(WebGLProgram program, DOMString name) raises(DOMException);

    any getParameter(GLenum pname) raises(DOMException);
    any getBufferParameter(GLenum target, GLenum pname) raises(DOMException);

    GLenum getError() raises(DOMException);

    any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, 
                                          GLenum pname) raises(DOMException);
    any getProgramParameter(WebGLProgram program, GLenum pname) raises(DOMException);
    DOMString getProgramInfoLog(WebGLProgram program) raises(DOMException);
    any getRenderbufferParameter(GLenum target, GLenum pname) raises(DOMException);
    any getShaderParameter(WebGLShader shader, GLenum pname) raises(DOMException);
    DOMString getShaderInfoLog(WebGLShader shader) raises(DOMException);

    DOMString getShaderSource(WebGLShader shader) raises(DOMException);
    DOMString getString(GLenum name) raises(DOMException);

    any getTexParameter(GLenum target, GLenum pname) raises(DOMException);

    any getUniform(WebGLProgram program, WebGLUniformLocation location) raises(DOMException);

    WebGLUniformLocation getUniformLocation(WebGLProgram program, DOMString name) raises(DOMException);

    any getVertexAttrib(GLuint index, GLenum pname) raises(DOMException);

    GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname) raises(DOMException);

    void hint(GLenum target, GLenum mode) raises(DOMException);
    GLboolean isBuffer(WebGLBuffer buffer) raises(DOMException);
    GLboolean isEnabled(GLenum cap) raises(DOMException);
    GLboolean isFramebuffer(WebGLFramebuffer framebuffer) raises(DOMException);
    GLboolean isProgram(WebGLProgram program) raises(DOMException);
    GLboolean isRenderbuffer(WebGLRenderbuffer renderbuffer) raises(DOMException);
    GLboolean isShader(WebGLShader shader) raises(DOMException);
    GLboolean isTexture(WebGLTexture texture) raises(DOMException);
    void lineWidth(GLfloat width) raises(DOMException);
    void linkProgram(WebGLProgram program) raises(DOMException);
    void pixelStorei(GLenum pname, GLint param) raises(DOMException);
    void polygonOffset(GLfloat factor, GLfloat units) raises(DOMException);

    WebGLArray readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                           GLenum format, GLenum type) raises(DOMException);

    void renderbufferStorage(GLenum target, GLenum internalformat, 
                             GLsizei width, GLsizei height) raises(DOMException);
    void sampleCoverage(GLclampf value, GLboolean invert) raises(DOMException);
    void scissor(GLint x, GLint y, GLsizei width, GLsizei height) 
                                                                        raises(DOMException);

    void shaderSource(WebGLShader shader, DOMString source) raises(DOMException);

    void stencilFunc(GLenum func, GLint ref, GLuint mask) raises(DOMException);
    void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask) 
                                                                        raises(DOMException);
    void stencilMask(GLuint mask) raises(DOMException);
    void stencilMaskSeparate(GLenum face, GLuint mask) raises(DOMException);
    void stencilOp(GLenum fail, GLenum zfail, GLenum zpass) raises(DOMException);
    void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass) 
                                                                        raises(DOMException);

    void texImage2D(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, GLenum format, 
                    GLenum type, WebGLArray pixels) raises(DOMException);
    void texImage2D(GLenum target, GLint level, ImageData pixels,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texImage2D(GLenum target, GLint level, HTMLImageElement image,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texImage2D(GLenum target, GLint level, HTMLCanvasElement canvas,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texImage2D(GLenum target, GLint level, HTMLVideoElement video,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha) 
                                                                        raises(DOMException);

    void texParameterf(GLenum target, GLenum pname, GLfloat param) 
                                                                        raises(DOMException);
    void texParameteri(GLenum target, GLenum pname, GLint param) raises(DOMException);

    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLsizei width, GLsizei height, 
                       GLenum format, GLenum type, WebGLArray pixels) 
                                                                        raises(DOMException);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       ImageData pixels,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)
                                                                        raises(DOMException);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       HTMLImageElement image,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       HTMLCanvasElement canvas,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha) 
                                                                        raises(DOMException);
    void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       HTMLVideoElement video,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha) 
                                                                        raises(DOMException);

    void uniform1f(WebGLUniformLocation location, GLfloat x) raises(DOMException);
    void uniform1fv(WebGLUniformLocation location, WebGLFloatArray v) raises(DOMException);
    void uniform1fv(WebGLUniformLocation location, sequence<float> v) raises(DOMException);
    void uniform1i(WebGLUniformLocation location, GLint x) raises(DOMException);
    void uniform1iv(WebGLUniformLocation location, WebGLIntArray v) raises(DOMException);
    void uniform1iv(WebGLUniformLocation location, sequence<long> v) raises(DOMException);
    void uniform2f(WebGLUniformLocation location, GLfloat x, GLfloat y) raises(DOMException);
    void uniform2fv(WebGLUniformLocation location, WebGLFloatArray v) raises(DOMException);
    void uniform2fv(WebGLUniformLocation location, sequence<float> v) raises(DOMException);
    void uniform2i(WebGLUniformLocation location, GLint x, GLint y) raises(DOMException);
    void uniform2iv(WebGLUniformLocation location, WebGLIntArray v) raises(DOMException);
    void uniform2iv(WebGLUniformLocation location, sequence<long> v) raises(DOMException);
    void uniform3f(WebGLUniformLocation location, GLfloat x, GLfloat y, GLfloat z) 
                                                                        raises(DOMException);
    void uniform3fv(WebGLUniformLocation location, WebGLFloatArray v) raises(DOMException);
    void uniform3fv(WebGLUniformLocation location, sequence<float> v) raises(DOMException);
    void uniform3i(WebGLUniformLocation location, GLint x, GLint y, GLint z) raises(DOMException);
    void uniform3iv(WebGLUniformLocation location, WebGLIntArray v) raises(DOMException);
    void uniform3iv(WebGLUniformLocation location, sequence<long> v) raises(DOMException);
    void uniform4f(WebGLUniformLocation location, GLfloat x, GLfloat y, GLfloat z, GLfloat w) 
                                                                        raises(DOMException);
    void uniform4fv(WebGLUniformLocation location, WebGLFloatArray v) raises(DOMException);
    void uniform4fv(WebGLUniformLocation location, sequence<float> v) raises(DOMException);
    void uniform4i(WebGLUniformLocation location, GLint x, GLint y, GLint z, GLint w) 
                                                                        raises(DOMException);
    void uniform4iv(WebGLUniformLocation location, WebGLIntArray v) raises(DOMException);
    void uniform4iv(WebGLUniformLocation location, sequence<long> v) raises(DOMException);

    void uniformMatrix2fv(WebGLUniformLocation location, GLboolean transpose, 
                          WebGLFloatArray value) raises(DOMException);
    void uniformMatrix2fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence<float> value) raises(DOMException);
    void uniformMatrix3fv(WebGLUniformLocation location, GLboolean transpose, 
                          WebGLFloatArray value) raises(DOMException);
    void uniformMatrix3fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence<float> value) raises(DOMException);
    void uniformMatrix4fv(WebGLUniformLocation location, GLboolean transpose, 
                          WebGLFloatArray value) raises(DOMException);
    void uniformMatrix4fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence<float> value) raises(DOMException);

    void useProgram(WebGLProgram program) raises(DOMException);
    void validateProgram(WebGLProgram program) raises(DOMException);

    void vertexAttrib1f(GLuint indx, GLfloat x) raises(DOMException);
    void vertexAttrib1fv(GLuint indx, WebGLFloatArray values) raises(DOMException);
    void vertexAttrib1fv(GLuint indx, sequence<float> values) raises(DOMException);
    void vertexAttrib2f(GLuint indx, GLfloat x, GLfloat y) raises(DOMException);
    void vertexAttrib2fv(GLuint indx, WebGLFloatArray values) raises(DOMException);
    void vertexAttrib2fv(GLuint indx, sequence<float> values) raises(DOMException);
    void vertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z) 
                                                                        raises(DOMException);
    void vertexAttrib3fv(GLuint indx, WebGLFloatArray values) raises(DOMException);
    void vertexAttrib3fv(GLuint indx, sequence<float> values) raises(DOMException);
    void vertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w) 
                                                                        raises(DOMException);
    void vertexAttrib4fv(GLuint indx, WebGLFloatArray values) raises(DOMException);
    void vertexAttrib4fv(GLuint indx, sequence<float> values) raises(DOMException);
    void vertexAttribPointer(GLuint indx, GLint size, GLenum type, 
                             GLboolean normalized, GLsizei stride, GLsizeiptr offset) 
                                                                        raises(DOMException);

    void viewport(GLint x, GLint y, GLsizei width, GLsizei height) 
                                                                        raises(DOMException);
};</pre>

<!-- ======================================================================================================= -->

    <h4>Attributes</h4>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt>
            <code class=attribute-name>
                <a id="DOM-WebGLRenderingContext-canvas">
                    canvas
                </a>
            </code> 
            of type <code>HTMLCanvasElement</code>
        <dd>
            A reference to the canvas element which created this context.

    </dl>

<!-- ======================================================================================================= -->

    <h4>The <code>getContextAttributes</code> method</h4>

    <dl class="methods">
        <dt class="idl-code">WebGLContextAttributes getContextAttributes()
        <dd>
            Returns the WebGLContextAttributes describing the current drawing buffer.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Setting and getting state</h4>

    <p>
        OpenGL ES 2.0 maintains state values for use in rendering. All the calls in this
        group behave identically to their OpenGL counterparts unless otherwise noted.
    </p>
    
    <dl class="methods">
        <dt class="idl-code">void activeTexture(GLenum texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glActiveTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code"void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendColor.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void blendEquation(GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendEquation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendEquationSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void blendFunc(GLenum sfactor, GLenum dfactor)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBlendFuncSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClearColor.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void clearDepth(GLclampf depth)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClearDepthf.xml">
                (OpenGL ES 2.0 man page)
            </a>
            <dd>
                <code>depth</code> value is clamped to the range 0 to 1.
        <dt class="idl-code">void clearStencil(GLint s)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClearStencil.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glColorMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void cullFace(GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCullFace.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void depthFunc(GLenum func)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDepthFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void depthMask(GLboolean flag)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDepthMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void depthRange(GLclampf zNear, GLclampf zFar)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDepthRangef.xml">
                (OpenGL ES 2.0 man page)
            </a>
            <dd>
                <code>zNear</code> and <code>zFar</code> values are clamped to the range 0 to 1.
        <dt class="idl-code">void disable(GLenum cap)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDisable.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void enable(GLenum cap)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glEnable.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void frontFace(GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFrontFace.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">any getParameter(GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGet.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>ACTIVE_TEXTURE</td><td>unsigned long</td></tr>
                <tr><td>ALIASED_LINE_WIDTH_RANGE</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>ALIASED_POINT_SIZE_RANGE</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>ALPHA_BITS</td><td>long</td></tr>
                <tr><td>ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>BLEND</td><td>boolean</td></tr>
                <tr><td>BLEND_COLOR</td><td>WebGLFloatArray (with 4 values)</td></tr>
                <tr><td>BLEND_DST_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_DST_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_EQUATION_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_ALPHA</td><td>unsigned long</td></tr>
                <tr><td>BLEND_SRC_RGB</td><td>unsigned long</td></tr>
                <tr><td>BLUE_BITS</td><td>long</td></tr>
                <tr><td>COLOR_CLEAR_VALUE</td><td>WebGLFloatArray (with 4 values)</td></tr>
                <tr><td>COLOR_WRITEMASK</td><td>WebGLUnsignedByteArray (with 4 values)</td></tr>
                <tr><td>COMPRESSED_TEXTURE_FORMATS</td><td>null</td></tr>
                <tr><td>CULL_FACE</td><td>boolean</td></tr>
                <tr><td>CULL_FACE_MODE</td><td>unsigned long</td></tr>
                <tr><td>CURRENT_PROGRAM</td><td>WebGLProgram</td></tr>
                <tr><td>DEPTH_BITS</td><td>long</td></tr>
                <tr><td>DEPTH_CLEAR_VALUE</td><td>float</td></tr>
                <tr><td>DEPTH_FUNC</td><td>unsigned long</td></tr>
                <tr><td>DEPTH_RANGE</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>DEPTH_TEST</td><td>boolean</td></tr>
                <tr><td>DEPTH_WRITEMASK</td><td>boolean</td></tr>
                <tr><td>DITHER</td><td>boolean</td></tr>
                <tr><td>ELEMENT_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>FRAMEBUFFER_BINDING</td><td>WebGLFramebuffer</td></tr>
                <tr><td>FRONT_FACE</td><td>unsigned long</td></tr>
                <tr><td>GENERATE_MIPMAP_HINT</td><td>unsigned long</td></tr>
                <tr><td>GREEN_BITS</td><td>long</td></tr>
                <tr><td>LINE_WIDTH</td><td>float</td></tr>
                <tr><td>MAX_COMBINED_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_CUBE_MAP_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_FRAGMENT_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_RENDERBUFFER_SIZE</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_TEXTURE_SIZE</td><td>long</td></tr>
                <tr><td>MAX_VARYING_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_ATTRIBS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_TEXTURE_IMAGE_UNITS</td><td>long</td></tr>
                <tr><td>MAX_VERTEX_UNIFORM_VECTORS</td><td>long</td></tr>
                <tr><td>MAX_VIEWPORT_DIMS</td><td>WebGLIntArray (with 2 elements)</td></tr>
                <tr><td>NUM_COMPRESSED_TEXTURE_FORMATS</td><td>long</td></tr>
                <tr><td>PACK_ALIGNMENT</td><td>long</td></tr>
                <tr><td>POLYGON_OFFSET_FACTOR</td><td>float</td></tr>
                <tr><td>POLYGON_OFFSET_FILL</td><td>boolean</td></tr>
                <tr><td>POLYGON_OFFSET_UNITS</td><td>float</td></tr>
                <tr><td>RED_BITS</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BINDING</td><td>WebGLRenderbuffer</td></tr>
                <tr><td>SAMPLE_BUFFERS</td><td>long</td></tr>
                <tr><td>SAMPLE_COVERAGE_INVERT</td><td>boolean</td></tr>
                <tr><td>SAMPLE_COVERAGE_VALUE</td><td>float</td></tr>
                <tr><td>SAMPLES</td><td>long</td></tr>
                <tr><td>SCISSOR_BOX</td><td>WebGLIntArray (with 4 elements)</td></tr>
                <tr><td>SCISSOR_TEST</td><td>boolean</td></tr>
                <tr><td>STENCIL_BACK_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_REF</td><td>long</td></tr>
                <tr><td>STENCIL_BACK_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BACK_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_BITS</td><td>long</td></tr>
                <tr><td>STENCIL_CLEAR_VALUE</td><td>long</td></tr>
                <tr><td>STENCIL_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_FUNC</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_FAIL</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_PASS_DEPTH_PASS</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_REF</td><td>long</td></tr>
                <tr><td>STENCIL_TEST</td><td>boolean</td></tr>
                <tr><td>STENCIL_VALUE_MASK</td><td>unsigned long</td></tr>
                <tr><td>STENCIL_WRITEMASK</td><td>unsigned long</td></tr>
                <tr><td>SUBPIXEL_BITS</td><td>long</td></tr>
                <tr><td>TEXTURE_BINDING_2D</td><td>WebGLTexture</td></tr>
                <tr><td>TEXTURE_BINDING_CUBE_MAP</td><td>WebGLTexture</td></tr>
                <tr><td>UNPACK_ALIGNMENT</td><td>int</td></tr>
                <tr><td>VIEWPORT</td><td>WebGLIntArray (with 4 elements)</td></tr>
            </table>
        <dt class="idl-code">GLenum getError()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetError.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">DOMString getString(GLenum name)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetString.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void hint(GLenum target, GLenum mode)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glHint.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">GLboolean isEnabled(GLenum cap)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsEnabled.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void lineWidth(GLfloat width)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLineWidth.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void pixelStorei(GLenum pname, GLint param)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glPixelStorei.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void polygonOffset(GLfloat factor, GLfloat units)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glPolygonOffset.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void sampleCoverage(GLclampf value, GLboolean invert)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glSampleCoverage.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void stencilFunc(GLenum func, GLint ref, GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glStencilFunc.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glStencilFuncSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void stencilMask(GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glStencilMask.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void stencilMaskSeparate(GLenum face, GLuint mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glStencilMaskSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void stencilOp(GLenum fail, GLenum zfail, GLenum zpass)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glStencilOp.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glStencilOpSeparate.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Viewing and clipping</h4>

    <p>
        The viewport specifies the affine transformation of x and y from normalized device 
        coordinates to window coordinates. The size of the drawing buffer is determined by 
        the HTMLCanvasElement. The scissor box defines a rectangle which constrains drawing.
        When the scissor test is enabled only pixels that lie within  the scissor box can 
        be modified by drawing commands. When enabled drawing can only occur inside the 
        intersection of the viewport, canvas area and the scissor box. When the scissor test
        is not enabled drawing can only occur inside the intersection of the viewport and 
        canvas area.
    </p>

    <dl class="methods">
        <dt class="idl-code">void scissor(GLint x, GLint y, GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glScissor.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void viewport(GLint x, GLint y, GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glViewport.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Buffer objects</h4>

    <p>
        Buffer objects (sometimes referred to as VBOs) hold vertex attribute data for the GLSL
        shaders.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindBuffer(GLenum target, WebGLBuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindBuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Binds the given WebGLBuffer object to the given binding point (target), either
            ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER. If the buffer is null then any buffer currently
            bound to this target is unbound. A given WebGLBuffer object may only be bound to one of
            the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime. An attempt to bind a
            buffer object to the other target will result in an INVALID_OPERATION error, and the
            current binding will remain untouched.
        
        <dt class="idl-code">void bufferData(GLenum target, GLsizei size, GLenum usage)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBufferData.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target. The
            buffer is initialized to 0.
            
        <dt><p class="idl-code">void bufferData(GLenum target, WebGLArray data, GLenum usage)</p>
            <p class="idl-code">void bufferData(GLenum target, WebGLArrayBuffer data, GLenum usage)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBufferData.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dd>
            Set the size of the currently bound WebGLBuffer object for the passed target to the 
            size of the passed data, then write the contents of data to the buffer object.
            
        <dt><p class="idl-code">void bufferSubData(GLenum target, GLsizeiptr offset, WebGLArray data)</p>
            <p class="idl-code">void bufferSubData(GLenum target, GLsizeiptr offset, WebGLArrayBuffer data)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBufferSubData.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dd>
            For the WebGLBuffer object bound to the passed target write the passed data starting
            at the passed offset. If the data would be written past the end of the buffer object
            an INVALID_VALUE error is raised.
            
        <dt class="idl-code">WebGLBuffer createBuffer()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenBuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLBuffer object and initialize it with a buffer object name as if by
            calling glGenBuffers.
            
        <dt class="idl-code">void deleteBuffer(WebGLBuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteBuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the buffer object contained in the passed WebGLBuffer as if by calling
            glDeleteBuffers. If the buffer has already been deleted the call has no effect.
            Note that the buffer object will be deleted when the WebGLBuffer object is destroyed.
            This method merely gives the author greater control over when the buffer object is
            destroyed.

        <dt class="idl-code">any getBufferParameter(GLenum target, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetBufferParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>BUFFER_SIZE</td><td>long</td></tr>
                <tr><td>BUFFER_USAGE</td><td>unsigned long</td></tr>
            </table>
        <dt class="idl-code">GLboolean isBuffer(WebGLBuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsBuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Framebuffer objects</h4>

    <p>
        Framebuffer objects provide an alternative rendering target to the drawing buffer. They
        are a collection of color, alpha, depth and stencil buffers and are often used to 
        render an image that will later be used as a texture.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindFramebuffer(GLenum target, WebGLFramebuffer framebuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindFramebuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        
        <dt class="idl-code">GLenum checkFramebufferStatus(GLenum target)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCheckFramebufferStatus.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">WebGLFramebuffer createFramebuffer()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenFramebuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLFramebuffer object and initialize it with a framebuffer object name as if by
            calling glGenFramebuffers.
            
        <dt class="idl-code">void deleteFramebuffer(WebGLFramebuffer buffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteFramebuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the framebuffer object contained in the passed WebGLFramebuffer as if by calling
            glDeleteFramebuffers. If the framebuffer has already been deleted the call has no effect.
            Note that the framebuffer object will be deleted when the WebGLFramebuffer object is destroyed.
            This method merely gives the author greater control over when the framebuffer object is
            destroyed.

        <dt class="idl-code">void framebufferRenderbuffer(GLenum target, GLenum attachment, 
                                 GLenum renderbuffertarget, 
                                 WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFramebufferRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a></dt>
        <dt class="idl-code">void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, 
                              WebGLTexture texture, GLint level)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFramebufferTexture2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, 
                                          GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetFramebufferAttachmentParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed target and attachment. The type 
            returned is the natural type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</td><td>unsigned long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</td><td>WebGLRenderbuffer or WebGLTexture</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</td><td>long</td></tr>
                <tr><td>FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</td><td>long</td></tr>
            </table>
        <dt class="idl-code">GLboolean isFramebuffer(WebGLFramebuffer framebuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsFramebuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLFramebuffer is valid and false otherwise.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Renderbuffer objects</h4>

    <p>
        Renderbuffer objects are used to provide storage for the individual buffers used in a
        framebuffer object.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindRenderbuffer(GLenum target, WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        
        <dt class="idl-code">WebGLRenderbuffer createRenderbuffer()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenRenderbuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLRenderbuffer object and initialize it with a renderbuffer object name as if by
            calling glGenRenderbuffers.
            
        <dt class="idl-code">void deleteRenderbuffer(WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteRenderbuffers.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the renderbuffer object contained in the passed WebGLRenderbuffer as if by calling
            glDeleteRenderbuffers. If the renderbuffer has already been deleted the call has no effect.
            Note that the renderbuffer object will be deleted when the WebGLRenderbuffer object is destroyed.
            This method merely gives the author greater control over when the renderbuffer object is
            destroyed.
        <dt class="idl-code">any getRenderbufferParameter(GLenum target, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetRenderbufferParameteriv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>RENDERBUFFER_WIDTH</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_HEIGHT</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_INTERNAL_FORMAT</td><td>unsigned long</td></tr>
                <tr><td>RENDERBUFFER_RED_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_GREEN_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_BLUE_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_ALPHA_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_DEPTH_SIZE</td><td>long</td></tr>
                <tr><td>RENDERBUFFER_STENCIL_SIZE</td><td>long</td></tr>
            </table>
        <dt class="idl-code">GLboolean isRenderbuffer(WebGLRenderbuffer renderbuffer)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsRenderbuffer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLRenderbuffer is valid and false otherwise.
        <dt class="idl-code">void renderbufferStorage(GLenum target, GLenum internalformat, 
                             GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glRenderbufferStorage.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Texture objects</h4>

    <p>
        Texture objects provide storage and state for texturing operations. If no WebGLTexture is bound
        (e.g., passing null or 0 to bindTexture) then attempts to modify the texture object shall
        raise an INVALID_OPERATION error. This is indicated in the functions below.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void bindTexture(GLenum target, WebGLTexture texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, 
                        GLint x, GLint y, GLsizei width, GLsizei height, 
                        GLint border)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCopyTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt class="idl-code">void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                           GLint x, GLint y, GLsizei width, GLsizei height)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCopyTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt class="idl-code">WebGLTexture createTexture()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenTextures.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLTexture object and initialize it with a texture object name as if by
            calling glGenTextures.
            
        <dt class="idl-code">void deleteTexture(WebGLTexture texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteTextures.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the texture object contained in the passed WebGLTexture as if by calling
            glDeleteTextures. If the texture has already been deleted the call has no effect.
            Note that the texture object will be deleted when the WebGLTexture object is destroyed.
            This method merely gives the author greater control over when the texture object is
            destroyed.
        <dt class="idl-code">void generateMipmap(GLenum target)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGenerateMipmap.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt class="idl-code">any getTexParameter(GLenum target, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetTexParameter.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed target. The type returned is the natural type for the
            requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>TEXTURE_MAG_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_MIN_FILTER</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_S</td><td>unsigned long</td></tr>
                <tr><td>TEXTURE_WRAP_T</td><td>unsigned long</td></tr>
            </table>
        <dt class="idl-code">GLboolean isTexture(WebGLTexture texture)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsTexture.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLTexture is valid and false otherwise.
        <dt class="idl-code">texImage2D(GLenum target, GLint level, GLenum internalformat, 
                    GLsizei width, GLsizei height, GLint border, GLenum format, 
                    GLenum type, WebGLArray pixels)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If the passed <code>pixels</code> value is <code>null</code> a buffer of sufficient size
            initialized to 0 is passed.
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt><p class="idl-code">void texImage2D(GLenum target, GLint level, ImageData pixels,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, HTMLImageElement image,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, HTMLCanvasElement canvas,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)</p>
            <p class="idl-code">void texImage2D(GLenum target, GLint level, HTMLVideoElement video,
                    optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dd>
            If the flipY parameter is false, the upper left pixel of the passed image is sent first and
            then transfer proceeds across and then down the image. If the flipY parameter is true, the
            lower left pixel of the passed image is sent first and then transfer proceeds across and then
            up the image.
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt class="idl-code">void texParameterf(GLenum target, GLenum pname, GLfloat param)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexParameter.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt class="idl-code">void texParameteri(GLenum target, GLenum pname, GLint param)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexParameter.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       GLsizei width, GLsizei height, 
                       GLenum format, GLenum type, WebGLArray pixels)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
        <dt><p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       ImageData pixels,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       HTMLImageElement image,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       HTMLCanvasElement canvas,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)</p>
            <p class="idl-code">void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, 
                       HTMLVideoElement video,
                       optional GLboolean flipY, optional GLboolean asPremultipliedAlpha)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glTexSubImage2D.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dd>
            If the flipY parameter is false, the upper left pixel of the passed image is sent first and
            then transfer proceeds across and then down the image. If the flipY parameter is true, the
            lower left pixel of the passed image is sent first and then transfer proceeds across and then
            up the image.
            If an attempt is made to call this function with no WebGLTexture bound (see above), an
            INVALID_OPERATION error is raised.
    </dl>
     
<!-- ======================================================================================================= -->

    <h4>Programs and Shaders</h4>

    <p>
        Rendering with OpenGL ES 2.0 requires the use of <i>shaders</i>, written in OpenGL's shading
        language, GLSL. Shaders must be loaded with a source string (shaderSource), compiled
        (compileShader) and attached to a <i>program</i> (attachShader) which must be linked
        (linkProgram) and then used (useProgram).
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void attachShader(WebGLProgram program, WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glAttachShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void bindAttribLocation(WebGLProgram program, GLuint index, DOMString name)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glBindAttribLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void compileShader(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCompileShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">WebGLProgram createProgram()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLProgram object and initialize it with a program object name as if by
            calling glCreateProgram.
            
        <dt class="idl-code">WebGLShader createShader(type)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glCreateShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Create a WebGLShader object and initialize it with a shader object name as if by
            calling glCreateShader.
            
        <dt class="idl-code">void deleteProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the program object contained in the passed WebGLProgram as if by calling
            glDeleteProgram. If the program has already been deleted the call has no effect.
            Note that the program object will be deleted when the WebGLProgram object is destroyed.
            This method merely gives the author greater control over when the program object is
            destroyed.
        <dt class="idl-code">void deleteShader(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDeleteShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Delete the shader object contained in the passed WebGLShader as if by calling
            glDeleteShader. If the shader has already been deleted the call has no effect.
            Note that the shader object will be deleted when the WebGLShader object is destroyed.
            This method merely gives the author greater control over when the shader object is
            destroyed.
        <dt class="idl-code">void detachShader(WebGLProgram program, WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDetachShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">WebGLObjectArray getAttachedShaders(GLuint program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetAttachedShaders.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the list of shaders attached to the passed program.
        <dt class="idl-code">any getProgramParameter(WebGLProgram program, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetProgramiv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed program. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>LINK_STATUS</td><td>boolean</td></tr>
                <tr><td>VALIDATE_STATUS</td><td>boolean</td></tr>
                <tr><td>INFO_LOG_LENGTH</td><td>long</td></tr>
                <tr><td>ATTACHED_SHADERS</td><td>long</td></tr>
                <tr><td>ACTIVE_ATTRIBUTES</td><td>long</td></tr>
                <tr><td>ACTIVE_ATTRIBUTE_MAX_LENGTH</td><td>long</td></tr>
                <tr><td>ACTIVE_UNIFORMS</td><td>long</td></tr>
                <tr><td>ACTIVE_UNIFORM_MAX_LENGTH</td><td>long</td></tr>
            </table>
        <dt class="idl-code">DOMString getProgramInfoLog(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetProgramInfoLog.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">any getShaderParameter(WebGLShader shader, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetShaderiv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the value for the passed pname given the passed shader. The type returned is the natural 
            type for the requested pname, as given in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>SHADER_TYPE</td><td>unsigned long</td></tr>
                <tr><td>DELETE_STATUS</td><td>boolean</td></tr>
                <tr><td>COMPILE_STATUS</td><td>boolean</td></tr>
                <tr><td>INFO_LOG_LENGTH</td><td>long</td></tr>
                <tr><td>SHADER_SOURCE_LENGTH</td><td>long</td></tr>
            </table>
        <dt class="idl-code">DOMString getShaderInfoLog(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetShaderInfoLog.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">DOMString getShaderSource(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetShaderSource.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">GLboolean isProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLProgram is valid and false otherwise.
        <dt class="idl-code">GLboolean isShader(WebGLShader shader)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glIsShader.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return true if the passed WebGLShader is valid and false otherwise.
        <dt class="idl-code">void linkProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glLinkProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void shaderSource(WebGLShader shader, DOMString source)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glShaderSource.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void useProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUseProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void validateProgram(WebGLProgram program)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glValidateProgram.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Uniforms and attributes</h4>

    <p>
        Values used by the shaders are passed in as uniform of vertex attributes.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void disableVertexAttribArray(GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDisableVertexAttribArray.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void enableVertexAttribArray(GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glEnableVertexAttribArray.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">WebGLActiveInfo getActiveAttrib(GLuint program, GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetActiveAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Returns information about the size, type and name of the vertex attribute at the
            passed index of the passed program object.
        <dt class="idl-code">WebGLActiveInfo getActiveUniform(GLuint program, GLuint index)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetActiveUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Returns information about the size, type and name of the uniform at the
            passed index of the passed program object.
        <dt class="idl-code">GLint getAttribLocation(WebGLProgram program, DOMString name)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetAttribLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">any getUniform(WebGLProgram program, WebGLUniformLocation location)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the uniform value at the passed location in the passed program. The type returned is 
            dependent on the uniform type, as shown in the following table:
            <table class="foo">
                <tr><th>uniform type</th><th>returned type</th></tr>
                <tr><td>boolean</td><td>boolean</td></tr>
                <tr><td>int</td><td>long</td></tr>
                <tr><td>float</td><td>float</td></tr>
                <tr><td>vec2</td><td>WebGLFloatArray (with 2 elements)</td></tr>
                <tr><td>ivec2</td><td>WebGLIntArray (with 2 elements)</td></tr>
                <tr><td>bvec2</td><td>WebGLUnsignedByteArray (with 2 elements)</td></tr>
                <tr><td>vec3</td><td>WebGLFloatArray (with 3 elements)</td></tr>
                <tr><td>ivec3</td><td>WebGLIntArray (with 3 elements)</td></tr>
                <tr><td>bvec3</td><td>WebGLUnsignedByteArray (with 3 elements)</td></tr>
                <tr><td>vec4</td><td>WebGLFloatArray (with 4 elements)</td></tr>
                <tr><td>ivec4</td><td>WebGLIntArray (with 4 elements)</td></tr>
                <tr><td>bvec4</td><td>WebGLUnsignedByteArray (with 4 elements)</td></tr>
                <tr><td>mat2</td><td>WebGLFloatArray (with 4 elements)</td></tr>
                <tr><td>mat3</td><td>WebGLFloatArray (with 9 elements)</td></tr>
                <tr><td>mat4</td><td>WebGLFloatArray (with 16 elements)</td></tr>
            </table>
        <dt class="idl-code">WebGLUniformLocation getUniformLocation(WebGLProgram program, DOMString name)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetUniformLocation.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return a WebGLUniformLocation object that represents the location of a specific uniform variable
            within a program object. The return value is null if name does not correspond to an active uniform
            variable in the passed program.

        <dt class="idl-code">any getVertexAttrib(GLuint index, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return the information requested in pname about the vertex attribute at the passed index. The 
            type returned is dependent on the information requested, as shown in the following table:
            <table class="foo">
                <tr><th>pname</th><th>returned type</th></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</td><td>WebGLBuffer</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_ENABLED</td><td>boolean</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_SIZE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_STRIDE</td><td>long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_TYPE</td><td>unsigned long</td></tr>
                <tr><td>VERTEX_ATTRIB_ARRAY_NORMALIZED</td><td>boolean</td></tr>
                <tr><td>CURRENT_VERTEX_ATTRIB</td><td>WebGLFloatArray (with 4 elements)</td></tr>
            </table>
        <dt class="idl-code">GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glGetVertexAttribPointerv.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void uniform1f(WebGLUniformLocation location, GLfloat x)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform1fv(WebGLUniformLocation location, WebGLFloatArray v)</p>
            <p class="idl-code">void uniform1fv(WebGLUniformLocation location, sequence&lt;float&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void uniform1i(WebGLUniformLocation location, GLint x)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform1iv(WebGLUniformLocation location, WebGLIntArray v)</p>
            <p class="idl-code">void uniform1iv(WebGLUniformLocation location, sequence&lt;long&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void uniform2f(WebGLUniformLocation location, GLfloat x, GLfloat y)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform2fv(WebGLUniformLocation location, WebGLFloatArray v)</p>
            <p class="idl-code">void uniform2fv(WebGLUniformLocation location, sequence&lt;float&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void uniform2i(WebGLUniformLocation location, GLint x, GLint y)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform2iv(WebGLUniformLocation location, WebGLIntArray v)</p>
            <p class="idl-code">void uniform2iv(WebGLUniformLocation location, sequence&lt;long&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void uniform3f(WebGLUniformLocation location, GLfloat x, GLfloat y, GLfloat z)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform3fv(WebGLUniformLocation location, WebGLFloatArray v)</p>
            <p class="idl-code">void uniform3fv(WebGLUniformLocation location, sequence&lt;float&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void uniform3i(WebGLUniformLocation location, GLint x, GLint y, GLint z)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform3iv(WebGLUniformLocation location, WebGLIntArray v)</p>
            <p class="idl-code">void uniform3iv(WebGLUniformLocation location, sequence&lt;long&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void uniform4f(WebGLUniformLocation location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform4fv(WebGLUniformLocation location, WebGLFloatArray v)</p>
            <p class="idl-code">void uniform4fv(WebGLUniformLocation location, sequence&lt;float&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void uniform4i(WebGLUniformLocation location, GLint x, GLint y, GLint z, GLint w)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void uniform4iv(WebGLUniformLocation location, WebGLIntArray v)</p>
            <p class="idl-code">void uniform4iv(WebGLUniformLocation location, sequence&lt;long&gt; v)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt><p class="idl-code">void uniformMatrix2fv(WebGLUniformLocation location, GLboolean transpose, 
                          WebGLFloatArray value)</p>
            <p class="idl-code">void uniformMatrix2fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence&lt;float&gt; value)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt><p class="idl-code">void uniformMatrix3fv(WebGLUniformLocation location, GLboolean transpose, 
                          WebGLFloatArray value)</p>
            <p class="idl-code">void uniformMatrix3fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence&lt;float&gt; value)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt><p class="idl-code">void uniformMatrix4fv(WebGLUniformLocation location, GLboolean transpose, 
                          WebGLFloatArray value)<br>
            <p class="idl-code">void uniformMatrix4fv(WebGLUniformLocation location, GLboolean transpose, 
                          sequence&lt;float&gt; value)<br>
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glUniform.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
       <dd>
            Each of the uniform* functions above sets the specified uniform or uniforms to the values 
            provided. The passed <code>location</code> must have been obtained from the currently used 
            program via an earlier call to <code>getUniformLocation</code>, or an INVALID_VALUE error
            will be raised.
        <dt class="idl-code">void vertexAttrib1f(GLuint indx, GLfloat x)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void vertexAttrib1fv(GLuint indx, WebGLFloatArray values)</p>
            <p class="idl-code">void vertexAttrib1fv(GLuint indx, sequence&lt;float&gt; values)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void vertexAttrib2f(GLuint indx, GLfloat x, GLfloat y)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void vertexAttrib2fv(GLuint indx, WebGLFloatArray values)</p>
            <p class="idl-code">void vertexAttrib2fv(GLuint indx, sequence&lt;float&gt; values)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void vertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void vertexAttrib3fv(GLuint indx, WebGLFloatArray values)</p>
            <p class="idl-code">voidvoid vertexAttrib3fv(GLuint indx, sequence&lt;float&gt; values)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
        <dt class="idl-code">void vertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt><p class="idl-code">void vertexAttrib4fv(GLuint indx, WebGLFloatArray values)</p>
            <p class="idl-code">void vertexAttrib4fv(GLuint indx, sequence&lt;float&gt; values)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttrib.xml">
                (OpenGL ES 2.0 man page)
            </a></p>
         <dt class="idl-code">void vertexAttribPointer(GLuint indx, GLint size, GLenum type, 
                             GLboolean normalized, GLsizei stride, GLsizeiptr offset)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glVertexAttribPointer.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Assign the currently bound WebGLBuffer object to the passed vertex attrib index.
            Size is number of components per attribute. Stride and offset are in units of bytes.
            Passed stride and offset must be appropriate for the passed type and size or an
            INVALID_VALUE error will be raised.
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Writing to the drawing buffer</h4>

    <p>
        OpenGL ES 2.0 has 3 calls which can render to the drawing buffer: <code>clear</code>, 
        <code>drawArrays</code> and <code>drawElements</code>. Furthermore rendering can
        be directed to the drawing buffer or to a Framebuffer object. When rendering is
        directed to the drawing buffer, making any of the 3 rendering calls shall 
        cause the drawing buffer to be presented to the HTML page compositor at the start
        of the next compositing operation.
    </p>
     
    <dl class="methods">
        <dt class="idl-code">void clear(GLbitfield mask)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glClear.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void drawArrays(GLenum mode, GLint first, GLsizei count)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDrawArrays.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void drawElements(GLenum mode, GLsizei count, GLenum type, GLsizeiptr offset)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glDrawElements.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Draw using the currently bound index array.  The given
            offset is in bytes, and must be a valid multiple of the
            size of the given type or an INVALID_VALUE error will be
            raised.
        <dt class="idl-code">void finish()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFinish.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dt class="idl-code">void flush()
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glFlush.xml">
                (OpenGL ES 2.0 man page)
            </a>
    </dl>

<!-- ======================================================================================================= -->

    <h4>Reading back pixels</h4>

    <p>
        Pixels in the current framebuffer can be read back into a WebGLArray object.
    </p>

    <dl class="methods">
        <dt class="idl-code">WebGLArray readPixels(GLint x, GLint y, GLsizei width, GLsizei height, 
                           GLenum format, GLenum type)
            <a class="gl-spec" href="http://www.khronos.org/opengles/sdk/docs/man/glReadPixels.xml">
                (OpenGL ES 2.0 man page)
            </a>
        <dd>
            Return a WebGLArray with pixels within the passed rectangle. The data returned from
            readPixels must be up-to-date as of the most recently sent drawing command. Any
            unprocessed drawing commands must be completed and their results presented to the
            current drawing buffers before readPixels accesses the drawing buffer. <br><br>

            The specific subclass of WebGLArray returned depends on the passed type. If it is
            GL_UNSIGNED_BYTE, a WebGLUnsignedByteArray is returned, otherwise a
            WebGLUnsignedShortArray is returned.
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Recovering from context lost events</h4>

    <p>
        Occurrences such as power events on mobile devices may cause the WebGL rendering context to
        be lost at any time and require the application to rebuild it; see the section on
        the <a href="#5.16.1">WebGLContextLostEvent</a> for more details. The
        following methods assist in detecting and recovering from context lost events.
    </p>

    <dl class="methods">
        <dt class="idl-code">boolean isContextLost()
        <dd>
            Returns true if the context is in the lost state.
        <dt class="idl-code">boolean resetContext()
        <dd>
            Returns true if the context was reset successfully.
    </dl>
    
<!-- ======================================================================================================= -->

    <h4>Detecting and enabling extensions</h4>

    <p>
        An implementation of WebGL must not support any additional parameters, constants or functions
        without first enabling that functionality through the extension mechanism. The 
        <code>getSupportedExtensions</code> function returns an array of the extension strings supported
        by this implementation. Extension strings are case-insensitive. An extension is enabled by 
        passing one of those strings to the <code>getExtension</code> function. This call returns an 
        object which contains any constants or functions defined by that extension. The definition of 
        that object is specific to the extension and must be defined by the extension specification.
    </p>
    <p>
        Once an extension is enabled, no mechanism is provided to disable it. Multiple calls to
        <code>getExtension</code> with the same extension string shall return the same object. An 
        attempt to use any features of an extension without first calling getExtension to enable it 
        must return the appropriate GL error and must not make use of the feature.
    </p>
    <p>
        This specification does not define any extensions. Browser specific extensions must have a 
        browser specific prefix, (e.g., "webkit-" or "moz-"). 
    </p>

    <dl class="methods">
        <dt class="idl-code">DOMString[ ] getSupportedExtensions()
        <dd>
            Returns an array of all the supported extension strings. Any string in this list, when 
            passed to <code>getExtension</code> must return a valid object. Any other string passed to 
            <code>getExtension</code> must return null.
            
        <dt class="idl-code">object getExtension(DOMString name)
        <dd>
            Returns an object if the passed extension is supported, or null if not. The object 
            returned from <code>getExtension</code> contains any constants or functions used by the 
            extension, if any. A returned object may have no constants or functions if the extension does 
            not define any, but a unique object must still be returned. That object is used to indicate 
            that the extension has been enabled. 
    </dl>

<!-- ======================================================================================================= -->

    <h3>Events</h3>

    <p>
        WebGL generates events when certain system activity occurs affecting the context.
        These events are sent to the corresponding HTMLCanvasElement through the
        <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html">DOM Event System</a>.
    </p>

<!-- ======================================================================================================= -->

    <h4>WebGLContextLostEvent</h4>

    <p>
        This event occurs when some system activity external to WebGL causes the rendering context
        to lose all of its state. The <span class="prop-name"><code>context</code></span> attribute
        contains the WebGLRenderingContext whose state was lost.
    </p>
    <p>
        When a WebGLContextLostEvent is delivered for a given context, that context is in a "lost"
        state. While the context is in the lost state, all rendering commands are ignored, and the
        context's <code>isContextLost</code> method will return true. In order to resume rendering,
        the application must call the context's <code>resetContext</code> method, and the invocation
        must return true. Once the context is reset, the application must reinitialize the context's
        state and recreate all of its WebGL resources such as textures, shaders and programs.
    </p>
    <pre class="idl">
interface <dfn id="WebGLContextLostEvent">WebGLContextLostEvent</dfn> : Event {
    readonly attribute WebGLRenderingContext context;
    
    void initWebGLContextLostEvent(DOMString type,
                                   boolean canBubble,
                                   boolean cancelable,
                                   WebGLRenderingContext context);
};</pre>

    <h5>Attributes</h5>

    <p>
        The following attributes are available:
    </p>

    <dl class="methods">
        <dt><span class="prop-name"><code>context</code></span> of type <code>WebGLRenderingContext</code>
        <dd>
            The context whose state was lost.
    </dl>

    <h5>Methods</h5>

    <p>
        The following methods are available:
    </p>

    <dl class="methods">
        <dt class="idl-code">void initWebGLContextLostEvent(DOMString type, boolean canBubble, boolean cancelable, WebGLRenderingContext context)
        <dd>
            Initialize the event created through the 
            <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event">Event</a>
            interface. This method may only be called before the event has been dispatched via
            the <code>dispatchEvent</code> method, though it may be called multiple times during
            that phase if necessary. If called multiple times, the final invocation takes
            precedence.
            <P>
            <b>Parameters</b>
            <dl>
                <dt><code>type</code> of type <code>DOMString</code>
                <dd>Specifies the event type, which is the string <code>webglcontextlost</code>.
                <dt><code>canBubble</code> of type <code>boolean</code>
                <dd>Specifies whether or not the event can bubble.
                <dt><code>cancelable</code> of type <code>boolean</code>
                <dd>Specifies whether or not the event can bubble.
                <dt><code>context</code> of type <code>WebGLRenderingContext</code>
                <dd>The context whose state was lost.
            </dl>
            <b>No Return Value</b><br>
            <b>No Exceptions</b><br>
    </dl>

    <div class="example">
    The following ECMAScript example shows how to register an event listener on a Canvas which will
    receive context lost events and attempt to restart the application.
    <pre>
var contextWhichWasLost = null;

function contextLostHandler(contextLostEvent) {
  // Start a timer to try to periodically reset the context
  contextWhichWasLost = contextLostEvent.context;
  setTimeout(tryToResetApplication, 500);
}

function tryToResetApplication() {
  if (contextWhichWasLost != null) {
    if (contextWhichWasLost.resetContext()) {
      var context = contextWhichWasLost;
      contextWhichWasLost = null;
      // Would re-run all of the initialization code for the application
      resetApplication(context);
    } else {
      setTimeout(tryToResetApplication, 500);
    }
  }
}

var canvas = document.getElementById('canvas1');
canvas.addEventListener("webglcontextlost", contextLostHandler, false);
    </pre>
    </div>

<!-- ======================================================================================================= -->

    <h2>Differences Between WebGL and OpenGL ES 2.0</h2>
    
<p>

This section describes changes made to the WebGL API relative to the OpenGL ES 2.0 API to improve
portability across various operating systems and devices.

</p>

    <h3>Buffer Object Binding</h3>

<p>

In the WebGL API, a given buffer object may only be bound to one of the <code>ARRAY_BUFFER</code> or
<code>ELEMENT_ARRAY_BUFFER</code> binding points in its lifetime. This restriction implies that a
given buffer object may contain either vertices or indices, but not both.

</p>
<p>

The type of a WebGLBuffer is initialized the first time it is passed as an argument
to <code>bindBuffer</code>. A subsequent call to <code>bindBuffer</code> which attempts to bind the
same WebGLBuffer to the other binding point will raise an <code>INVALID_OPERATION</code> error, and
the state of the binding point will remain untouched.

</p>

    <h3>Framebuffer Object Attachments</h3>

<p>

WebGL adds the <code>DEPTH_STENCIL_ATTACHMENT</code> framebuffer object attachment point and
the <code>DEPTH_STENCIL</code> renderbuffer internal format. To attach both depth and stencil
buffers to a framebuffer object, call <code>renderbufferStorage</code> with
the <code>DEPTH_STENCIL</code> internal format, and then call <code>framebufferRenderbuffer</code>
with the <code>DEPTH_STENCIL_ATTACHMENT</code> attachment point.

</p>
<p>

A renderbuffer attached to the <code>DEPTH_ATTACHMENT</code> attachment point must be allocated with
the <code>DEPTH_COMPONENT16</code> internal format. A renderbuffer attached to
the <code>STENCIL_ATTACHMENT</code> attachment point must be allocated with
the <code>STENCIL_INDEX8</code> internal format. Attempts to attach a renderbuffer with an incorrect
internal format to a particular attachment point will raise INVALID_OPERATION from the call
to <code>framebufferRenderbuffer</code> and leave the framebuffer's attachments untouched.

</p>
<p>

In WebGL, it is an error to concurrently attach renderbuffers to the following combinations of
attachment points:

<ul>
<li> <code>DEPTH_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
<li> <code>STENCIL_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
<li> <code>DEPTH_ATTACHMENT + STENCIL_ATTACHMENT</code>
</ul>

A call to <code>framebufferRenderbuffer</code> which would result in non-zero attachments to any of
these combinations of attachment points will raise an <code>INVALID_OPERATION</code> error and leave
the framebuffer's attachments untouched.

</p>

    <h3>GLSL Constructs</h3>

<p>
Per <a href="#4.4">Section 4.4</a>, identifiers starting with "webgl_" and "_webgl_" are reserved
for use by WebGL.
</p>

<!-- ======================================================================================================= -->

    <h2>References</h2>
    
    <h3>Normative references</h3>
    <dl>
    
        <dt id="refsGLES20">[GLES20]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.24.pdf">
            OpenGL&reg; ES Common Profile Specification Version 2.0.24</a></cite>, 
            A. Munshi, J. Leech, April 2009.
        </dd>
        <dt id="refsGLES20GLSL">[GLES20GLSL]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">
            The OpenGL&reg; ES Shading Language Version 1.00</a></cite>, 
            R. Simpson, May 2009.
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">
            Web IDL: W3C Editor’s Draft</a></cite>, 
            C. McCormack, September 2009.
        </dd>
    </dl>

    <h3>Other references</h3>

<!-- ======================================================================================================= -->
    
    <h2>Acknowledgments</h2>
    <p>This specification is produced by the Khronos WebGL Working Group.</p>
    
    <p>
       Special thanks to: Arun Ranganathan (Mozilla), Jon Leech, Kenneth Russell (Google), 
       Kenneth Waters (Google), Mark Callow (HI), Mark Steele (Mozilla), Oliver Hunt (Apple), 
       Tim Johansson (Opera), Vangelis Kokkevis (Google), Vladimir Vukicevic (Mozilla)
    </p>
    <p>
        Additional thanks to: Alan Hudson (Yumetech), Bill Licea Kane (AMD), Cedric Vivier (Zegami),
        Dan Gessel (Apple), David Ligon (Qualcomm), Greg Ross (Nvidia), Jacob Strom (Ericsson), Kari Pulli (Nokia),
        Leddie Stenvie (ST-Ericsson), Neil Trevett (Nvidia), Per Wennersten (Ericsson),
        Per-Erik Brodin (Ericsson), Shiki Okasaka (Google), Tom Olson (ARM), Zhengrong Yao (Ericsson),
        and the members of the Khronos WebGL Working Group.
</p>

</body>
</html>
